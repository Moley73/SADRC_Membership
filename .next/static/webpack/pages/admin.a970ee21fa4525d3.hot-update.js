"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/admin",{

/***/ "./lib/pdfExportHelper.js":
/*!********************************!*\
  !*** ./lib/pdfExportHelper.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportMembersToPDF: function() { return /* binding */ exportMembersToPDF; }\n/* harmony export */ });\n/* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jspdf */ \"./node_modules/jspdf/dist/jspdf.es.min.js\");\n/* harmony import */ var jspdf_autotable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jspdf-autotable */ \"./node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.mjs\");\n// PDF Export Helper\n\n\n/**\n * Exports the given members array to a styled PDF file.\n * @param {Array} members - Array of member objects to export.\n * @param {String} exportType - Type of export ('full', 'competitions', 'aaga', or 'summary')\n */ function exportMembersToPDF(members) {\n    let exportType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"summary\";\n    try {\n        // Create new document with landscape orientation for better table display\n        const doc = new jspdf__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            orientation: \"landscape\",\n            unit: \"mm\",\n            format: \"a4\"\n        });\n        const pageWidth = doc.internal.pageSize.getWidth();\n        const pageHeight = doc.internal.pageSize.getHeight();\n        const margin = 16;\n        const currentDate = new Date().toLocaleDateString(\"en-GB\"); // Format as DD/MM/YYYY\n        // Add club logo/branding\n        addBranding(doc, pageWidth, margin);\n        // Set document properties\n        doc.setProperties({\n            title: \"SADRC Membership Export\",\n            subject: \"Membership Data\",\n            author: \"SADRC Admin System\",\n            creator: \"SADRC Membership App\"\n        });\n        // Add title and subtitle\n        let title = \"\";\n        let startY = margin + 30; // Adjusted for logo\n        // Configure columns and data based on export type\n        switch(exportType){\n            case \"active\":\n                title = \"Active Members\";\n                break;\n            case \"pending\":\n                title = \"Pending Members\";\n                break;\n            case \"expired\":\n                title = \"Expired Members\";\n                break;\n            case \"competitions\":\n                title = \"Club Competitions Participants\";\n                break;\n            case \"aaga\":\n                title = \"AaGA Challenge Participants\";\n                break;\n            case \"summary\":\n            default:\n                title = \"Membership Summary\";\n                break;\n        }\n        // Section title\n        doc.setFont(\"helvetica\", \"bold\");\n        doc.setFontSize(18);\n        doc.setTextColor(0, 0, 0);\n        doc.text(title, pageWidth / 2, startY, {\n            align: \"center\"\n        });\n        // Stats summary\n        startY += 10;\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.setFontSize(10);\n        // Make sure we have valid data before trying to filter\n        const safeMembers = Array.isArray(members) ? members : [];\n        const approvedCount = safeMembers.filter((m)=>m && m.status === \"approved\").length;\n        const pendingCount = safeMembers.filter((m)=>m && (!m.status || m.status === \"pending\")).length;\n        const paidCount = safeMembers.filter((m)=>m && m.payment_status === \"paid\").length;\n        const competitionsCount = safeMembers.filter((m)=>m && m.opt_in_competitions === true).length;\n        const aagaCount = safeMembers.filter((m)=>m && m.opt_in_aaga_challenge === true).length;\n        const activeCount = safeMembers.filter((m)=>m && m.membership_status === \"active\").length;\n        // Create a stats box\n        const statsBoxY = startY;\n        const statsBoxHeight = 20;\n        // Draw stats box background\n        doc.setFillColor(245, 245, 245);\n        doc.roundedRect(margin, statsBoxY, pageWidth - margin * 2, statsBoxHeight, 3, 3, \"F\");\n        // Add stats text\n        doc.setTextColor(80, 80, 80);\n        doc.text(\"Total Members: \".concat(safeMembers.length, \" | Approved: \").concat(approvedCount, \" | Pending: \").concat(pendingCount, \" | Paid: \").concat(paidCount), margin + 5, statsBoxY + 8);\n        doc.text(\"Active: \".concat(activeCount, \" | Competition Participants: \").concat(competitionsCount, \" | AaGA Challenge Participants: \").concat(aagaCount), margin + 5, statsBoxY + 16);\n        startY += statsBoxHeight + 10;\n        // Determine columns based on export type\n        let columns = [];\n        let rows = [];\n        // Configure columns and data based on export type\n        switch(exportType){\n            case \"active\":\n            case \"pending\":\n            case \"expired\":\n                columns = [\n                    {\n                        header: \"First Name\",\n                        dataKey: \"first_name\"\n                    },\n                    {\n                        header: \"Surname\",\n                        dataKey: \"surname\"\n                    },\n                    {\n                        header: \"Email\",\n                        dataKey: \"email\"\n                    },\n                    {\n                        header: \"Date of Birth\",\n                        dataKey: \"date_of_birth\"\n                    },\n                    {\n                        header: \"Status\",\n                        dataKey: \"status\"\n                    },\n                    {\n                        header: \"Payment\",\n                        dataKey: \"payment_status\"\n                    },\n                    {\n                        header: \"EA Number\",\n                        dataKey: \"ea_number\"\n                    },\n                    {\n                        header: \"Expiry Date\",\n                        dataKey: \"membership_expiry\"\n                    }\n                ];\n                rows = safeMembers.map((m)=>({\n                        first_name: m.first_name || \"\",\n                        surname: m.surname || \"\",\n                        email: m.email || \"\",\n                        date_of_birth: formatDate(m.date_of_birth),\n                        status: formatStatus(m.status || \"pending\"),\n                        payment_status: m.payment_status === \"paid\" ? \"Paid\" : \"Unpaid\",\n                        ea_number: m.ea_number || \"Not registered\",\n                        membership_expiry: formatDate(m.membership_expiry)\n                    }));\n                break;\n            case \"competitions\":\n                const competitionMembers = safeMembers.filter((m)=>m && m.opt_in_competitions);\n                columns = [\n                    {\n                        header: \"First Name\",\n                        dataKey: \"first_name\"\n                    },\n                    {\n                        header: \"Surname\",\n                        dataKey: \"surname\"\n                    },\n                    {\n                        header: \"Email\",\n                        dataKey: \"email\"\n                    },\n                    {\n                        header: \"Date of Birth\",\n                        dataKey: \"date_of_birth\"\n                    },\n                    {\n                        header: \"Membership Status\",\n                        dataKey: \"membership_status\"\n                    },\n                    {\n                        header: \"Payment Status\",\n                        dataKey: \"payment_status\"\n                    },\n                    {\n                        header: \"EA Number\",\n                        dataKey: \"ea_number\"\n                    }\n                ];\n                rows = competitionMembers.map((m)=>({\n                        first_name: m.first_name || \"\",\n                        surname: m.surname || \"\",\n                        email: m.email || \"\",\n                        date_of_birth: formatDate(m.date_of_birth),\n                        membership_status: formatStatus(m.membership_status || \"pending\"),\n                        payment_status: m.payment_status === \"paid\" ? \"Paid\" : \"Unpaid\",\n                        ea_number: m.ea_number || \"Not registered\"\n                    }));\n                break;\n            case \"aaga\":\n                const aagaMembers = safeMembers.filter((m)=>m && m.opt_in_aaga_challenge);\n                columns = [\n                    {\n                        header: \"First Name\",\n                        dataKey: \"first_name\"\n                    },\n                    {\n                        header: \"Surname\",\n                        dataKey: \"surname\"\n                    },\n                    {\n                        header: \"Email\",\n                        dataKey: \"email\"\n                    },\n                    {\n                        header: \"Date of Birth\",\n                        dataKey: \"date_of_birth\"\n                    },\n                    {\n                        header: \"Membership Status\",\n                        dataKey: \"membership_status\"\n                    },\n                    {\n                        header: \"Payment Status\",\n                        dataKey: \"payment_status\"\n                    }\n                ];\n                rows = aagaMembers.map((m)=>({\n                        first_name: m.first_name || \"\",\n                        surname: m.surname || \"\",\n                        email: m.email || \"\",\n                        date_of_birth: formatDate(m.date_of_birth),\n                        membership_status: formatStatus(m.membership_status || \"pending\"),\n                        payment_status: m.payment_status === \"paid\" ? \"Paid\" : \"Unpaid\"\n                    }));\n                break;\n            case \"summary\":\n            default:\n                columns = [\n                    {\n                        header: \"First Name\",\n                        dataKey: \"first_name\"\n                    },\n                    {\n                        header: \"Surname\",\n                        dataKey: \"surname\"\n                    },\n                    {\n                        header: \"Email\",\n                        dataKey: \"email\"\n                    },\n                    {\n                        header: \"Status\",\n                        dataKey: \"status\"\n                    },\n                    {\n                        header: \"Payment\",\n                        dataKey: \"payment_status\"\n                    }\n                ];\n                rows = safeMembers.map((m)=>({\n                        first_name: m.first_name || \"\",\n                        surname: m.surname || \"\",\n                        email: m.email || \"\",\n                        status: formatStatus(m.status || \"pending\"),\n                        payment_status: m.payment_status === \"paid\" ? \"Paid\" : \"Unpaid\"\n                    }));\n                break;\n        }\n        // Table\n        (0,jspdf_autotable__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(doc, {\n            head: [\n                columns.map((col)=>col.header)\n            ],\n            body: rows.map((row)=>columns.map((col)=>row[col.dataKey])),\n            startY: startY,\n            margin: {\n                left: margin,\n                right: margin\n            },\n            styles: {\n                fontSize: 9,\n                cellPadding: 3,\n                valign: \"middle\",\n                overflow: \"ellipsize\",\n                textColor: [\n                    30,\n                    30,\n                    30\n                ],\n                halign: \"left\",\n                minCellHeight: 10,\n                lineWidth: 0.1,\n                cellWidth: \"wrap\"\n            },\n            headStyles: {\n                fillColor: [\n                    255,\n                    102,\n                    0\n                ],\n                textColor: [\n                    255,\n                    255,\n                    255\n                ],\n                fontStyle: \"bold\",\n                fontSize: 10,\n                halign: \"left\",\n                cellPadding: 4\n            },\n            alternateRowStyles: {\n                fillColor: [\n                    245,\n                    245,\n                    245\n                ]\n            },\n            columnStyles: getColumnStyles(columns),\n            didDrawPage: (data)=>{\n                // Add header to each page\n                if (data.pageNumber > 1) {\n                    addBranding(doc, pageWidth, margin);\n                }\n                // Add footer to each page\n                addFooter(doc, pageWidth, pageHeight, data.pageNumber, doc.getNumberOfPages(), margin);\n            }\n        });\n        // Save the PDF\n        const filename = \"sadrc_members_\".concat(exportType, \"_\").concat(new Date().toISOString().split(\"T\")[0], \".pdf\");\n        doc.save(filename);\n        return filename;\n    } catch (error) {\n        console.error(\"PDF Export Error Details:\", {\n            message: error.message || \"Unknown error\",\n            stack: error.stack || \"No stack trace\",\n            exportType: exportType || \"unknown\"\n        });\n        throw error; // Re-throw to allow the calling function to handle it\n    }\n}\n/**\n * Adds branding elements to the PDF\n */ function addBranding(doc, pageWidth, margin) {\n    try {\n        // Header background\n        doc.setFillColor(255, 102, 0);\n        doc.rect(0, 0, pageWidth, margin + 10, \"F\");\n        // Title\n        doc.setFontSize(24);\n        doc.setTextColor(255, 255, 255);\n        doc.setFont(\"helvetica\", \"bold\");\n        doc.text(\"SADRC Membership\", pageWidth / 2, margin, {\n            align: \"center\"\n        });\n        // Date line\n        doc.setDrawColor(255, 255, 255);\n        doc.setLineWidth(0.5);\n        doc.line(margin, margin + 4, pageWidth - margin, margin + 4);\n        // Export date\n        doc.setFontSize(11);\n        doc.setTextColor(255, 255, 255);\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.text(\"Export Date: \".concat(new Date().toLocaleDateString(\"en-GB\")), pageWidth / 2, margin + 10, {\n            align: \"center\"\n        });\n    } catch (error) {\n        console.error(\"Error in addBranding:\", error);\n    // Continue execution even if branding fails\n    }\n}\n/**\n * Adds a footer to each page\n */ function addFooter(doc, pageWidth, pageHeight, pageNumber, totalPages, margin) {\n    try {\n        // Footer line\n        doc.setDrawColor(200, 200, 200);\n        doc.setLineWidth(0.5);\n        doc.line(margin, pageHeight - 15, pageWidth - margin, pageHeight - 15);\n        // Page numbers and confidentiality notice\n        doc.setFontSize(8);\n        doc.setTextColor(120, 120, 120);\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.text(\"Skegness & District Running Club - Confidential - Page \".concat(pageNumber, \" of \").concat(totalPages), pageWidth / 2, pageHeight - 8, {\n            align: \"center\"\n        });\n    } catch (error) {\n        console.error(\"Error in addFooter:\", error);\n    // Continue execution even if footer fails\n    }\n}\n/**\n * Returns appropriate column styles based on the columns array\n */ function getColumnStyles(columns) {\n    try {\n        const styles = {};\n        // Set width for each column type - adjusted to prevent wrapping\n        columns.forEach((col, index)=>{\n            switch(col.dataKey){\n                case \"first_name\":\n                    styles[index] = {\n                        cellWidth: 30,\n                        overflow: \"ellipsize\"\n                    };\n                    break;\n                case \"surname\":\n                    styles[index] = {\n                        cellWidth: 30,\n                        overflow: \"ellipsize\"\n                    };\n                    break;\n                case \"email\":\n                    styles[index] = {\n                        cellWidth: 60,\n                        overflow: \"ellipsize\"\n                    };\n                    break;\n                case \"date_of_birth\":\n                case \"membership_expiry\":\n                    styles[index] = {\n                        cellWidth: 22,\n                        halign: \"center\",\n                        overflow: \"ellipsize\"\n                    };\n                    break;\n                case \"status\":\n                case \"membership_status\":\n                    styles[index] = {\n                        cellWidth: 22,\n                        halign: \"center\",\n                        overflow: \"ellipsize\"\n                    };\n                    break;\n                case \"payment_status\":\n                    styles[index] = {\n                        cellWidth: 18,\n                        halign: \"center\",\n                        overflow: \"ellipsize\"\n                    };\n                    break;\n                case \"ea_number\":\n                    styles[index] = {\n                        cellWidth: 25,\n                        halign: \"center\",\n                        overflow: \"ellipsize\"\n                    };\n                    break;\n                default:\n                    styles[index] = {\n                        cellWidth: \"auto\",\n                        overflow: \"ellipsize\"\n                    };\n            }\n        });\n        return styles;\n    } catch (error) {\n        console.error(\"Error in getColumnStyles:\", error);\n        return {}; // Return empty object as fallback\n    }\n}\n/**\n * Formats a date string to DD/MM/YYYY\n */ function formatDate(dateString) {\n    if (!dateString) return \"Not set\";\n    try {\n        const date = new Date(dateString);\n        if (isNaN(date.getTime())) return \"Invalid date\";\n        return date.toLocaleDateString(\"en-GB\");\n    } catch (e) {\n        console.error(\"Date formatting error:\", e);\n        return dateString || \"Not set\";\n    }\n}\n/**\n * Formats status with proper capitalization\n */ function formatStatus(status) {\n    if (!status) return \"Pending\";\n    try {\n        return status.charAt(0).toUpperCase() + status.slice(1);\n    } catch (e) {\n        console.error(\"Status formatting error:\", e);\n        return status || \"Pending\";\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFrQixDQUFDO0lBQ2pDLEVBQUUsT0FBTytGLEdBQUc7UUFDVmQsUUFBUUQsS0FBSyxDQUFDLDBCQUEwQmU7UUFDeEMsT0FBT0osY0FBYztJQUN2QjtBQUNGO0FBRUE7O0NBRUMsR0FDRCxTQUFTL0MsYUFBYXpCLE1BQU07SUFDMUIsSUFBSSxDQUFDQSxRQUFRLE9BQU87SUFFcEIsSUFBSTtRQUNGLE9BQU9BLE9BQU82RSxNQUFNLENBQUMsR0FBR0MsV0FBVyxLQUFLOUUsT0FBTytFLEtBQUssQ0FBQztJQUN2RCxFQUFFLE9BQU9ILEdBQUc7UUFDVmQsUUFBUUQsS0FBSyxDQUFDLDRCQUE0QmU7UUFDMUMsT0FBTzVFLFVBQVU7SUFDbkI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvcGRmRXhwb3J0SGVscGVyLmpzP2MwODEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUERGIEV4cG9ydCBIZWxwZXJcbmltcG9ydCBqc1BERiBmcm9tICdqc3BkZic7XG5pbXBvcnQgYXV0b1RhYmxlIGZyb20gJ2pzcGRmLWF1dG90YWJsZSc7XG5cbi8qKlxuICogRXhwb3J0cyB0aGUgZ2l2ZW4gbWVtYmVycyBhcnJheSB0byBhIHN0eWxlZCBQREYgZmlsZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG1lbWJlcnMgLSBBcnJheSBvZiBtZW1iZXIgb2JqZWN0cyB0byBleHBvcnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwb3J0VHlwZSAtIFR5cGUgb2YgZXhwb3J0ICgnZnVsbCcsICdjb21wZXRpdGlvbnMnLCAnYWFnYScsIG9yICdzdW1tYXJ5JylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cG9ydE1lbWJlcnNUb1BERihtZW1iZXJzLCBleHBvcnRUeXBlID0gJ3N1bW1hcnknKSB7XG4gIHRyeSB7XG4gICAgLy8gQ3JlYXRlIG5ldyBkb2N1bWVudCB3aXRoIGxhbmRzY2FwZSBvcmllbnRhdGlvbiBmb3IgYmV0dGVyIHRhYmxlIGRpc3BsYXlcbiAgICBjb25zdCBkb2MgPSBuZXcganNQREYoeyBvcmllbnRhdGlvbjogJ2xhbmRzY2FwZScsIHVuaXQ6ICdtbScsIGZvcm1hdDogJ2E0JyB9KTtcbiAgICBjb25zdCBwYWdlV2lkdGggPSBkb2MuaW50ZXJuYWwucGFnZVNpemUuZ2V0V2lkdGgoKTtcbiAgICBjb25zdCBwYWdlSGVpZ2h0ID0gZG9jLmludGVybmFsLnBhZ2VTaXplLmdldEhlaWdodCgpO1xuICAgIGNvbnN0IG1hcmdpbiA9IDE2O1xuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLUdCJyk7IC8vIEZvcm1hdCBhcyBERC9NTS9ZWVlZXG4gICAgXG4gICAgLy8gQWRkIGNsdWIgbG9nby9icmFuZGluZ1xuICAgIGFkZEJyYW5kaW5nKGRvYywgcGFnZVdpZHRoLCBtYXJnaW4pO1xuXG4gICAgLy8gU2V0IGRvY3VtZW50IHByb3BlcnRpZXNcbiAgICBkb2Muc2V0UHJvcGVydGllcyh7XG4gICAgICB0aXRsZTogJ1NBRFJDIE1lbWJlcnNoaXAgRXhwb3J0JyxcbiAgICAgIHN1YmplY3Q6ICdNZW1iZXJzaGlwIERhdGEnLFxuICAgICAgYXV0aG9yOiAnU0FEUkMgQWRtaW4gU3lzdGVtJyxcbiAgICAgIGNyZWF0b3I6ICdTQURSQyBNZW1iZXJzaGlwIEFwcCdcbiAgICB9KTtcblxuICAgIC8vIEFkZCB0aXRsZSBhbmQgc3VidGl0bGVcbiAgICBsZXQgdGl0bGUgPSAnJztcbiAgICBsZXQgc3RhcnRZID0gbWFyZ2luICsgMzA7IC8vIEFkanVzdGVkIGZvciBsb2dvXG5cbiAgICAvLyBDb25maWd1cmUgY29sdW1ucyBhbmQgZGF0YSBiYXNlZCBvbiBleHBvcnQgdHlwZVxuICAgIHN3aXRjaCAoZXhwb3J0VHlwZSkge1xuICAgICAgY2FzZSAnYWN0aXZlJzpcbiAgICAgICAgdGl0bGUgPSAnQWN0aXZlIE1lbWJlcnMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3BlbmRpbmcnOlxuICAgICAgICB0aXRsZSA9ICdQZW5kaW5nIE1lbWJlcnMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2V4cGlyZWQnOlxuICAgICAgICB0aXRsZSA9ICdFeHBpcmVkIE1lbWJlcnMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NvbXBldGl0aW9ucyc6XG4gICAgICAgIHRpdGxlID0gJ0NsdWIgQ29tcGV0aXRpb25zIFBhcnRpY2lwYW50cyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYWFnYSc6XG4gICAgICAgIHRpdGxlID0gJ0FhR0EgQ2hhbGxlbmdlIFBhcnRpY2lwYW50cyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aXRsZSA9ICdNZW1iZXJzaGlwIFN1bW1hcnknO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBTZWN0aW9uIHRpdGxlXG4gICAgZG9jLnNldEZvbnQoJ2hlbHZldGljYScsICdib2xkJyk7XG4gICAgZG9jLnNldEZvbnRTaXplKDE4KTtcbiAgICBkb2Muc2V0VGV4dENvbG9yKDAsIDAsIDApO1xuICAgIGRvYy50ZXh0KHRpdGxlLCBwYWdlV2lkdGggLyAyLCBzdGFydFksIHsgYWxpZ246ICdjZW50ZXInIH0pO1xuXG4gICAgLy8gU3RhdHMgc3VtbWFyeVxuICAgIHN0YXJ0WSArPSAxMDtcbiAgICBkb2Muc2V0Rm9udCgnaGVsdmV0aWNhJywgJ25vcm1hbCcpO1xuICAgIGRvYy5zZXRGb250U2l6ZSgxMCk7XG4gICAgXG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgdmFsaWQgZGF0YSBiZWZvcmUgdHJ5aW5nIHRvIGZpbHRlclxuICAgIGNvbnN0IHNhZmVNZW1iZXJzID0gQXJyYXkuaXNBcnJheShtZW1iZXJzKSA/IG1lbWJlcnMgOiBbXTtcbiAgICBcbiAgICBjb25zdCBhcHByb3ZlZENvdW50ID0gc2FmZU1lbWJlcnMuZmlsdGVyKG0gPT4gbSAmJiBtLnN0YXR1cyA9PT0gJ2FwcHJvdmVkJykubGVuZ3RoO1xuICAgIGNvbnN0IHBlbmRpbmdDb3VudCA9IHNhZmVNZW1iZXJzLmZpbHRlcihtID0+IG0gJiYgKCFtLnN0YXR1cyB8fCBtLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSkubGVuZ3RoO1xuICAgIGNvbnN0IHBhaWRDb3VudCA9IHNhZmVNZW1iZXJzLmZpbHRlcihtID0+IG0gJiYgbS5wYXltZW50X3N0YXR1cyA9PT0gJ3BhaWQnKS5sZW5ndGg7XG4gICAgY29uc3QgY29tcGV0aXRpb25zQ291bnQgPSBzYWZlTWVtYmVycy5maWx0ZXIobSA9PiBtICYmIG0ub3B0X2luX2NvbXBldGl0aW9ucyA9PT0gdHJ1ZSkubGVuZ3RoO1xuICAgIGNvbnN0IGFhZ2FDb3VudCA9IHNhZmVNZW1iZXJzLmZpbHRlcihtID0+IG0gJiYgbS5vcHRfaW5fYWFnYV9jaGFsbGVuZ2UgPT09IHRydWUpLmxlbmd0aDtcbiAgICBjb25zdCBhY3RpdmVDb3VudCA9IHNhZmVNZW1iZXJzLmZpbHRlcihtID0+IG0gJiYgbS5tZW1iZXJzaGlwX3N0YXR1cyA9PT0gJ2FjdGl2ZScpLmxlbmd0aDtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBzdGF0cyBib3hcbiAgICBjb25zdCBzdGF0c0JveFkgPSBzdGFydFk7XG4gICAgY29uc3Qgc3RhdHNCb3hIZWlnaHQgPSAyMDtcbiAgICBcbiAgICAvLyBEcmF3IHN0YXRzIGJveCBiYWNrZ3JvdW5kXG4gICAgZG9jLnNldEZpbGxDb2xvcigyNDUsIDI0NSwgMjQ1KTtcbiAgICBkb2Mucm91bmRlZFJlY3QobWFyZ2luLCBzdGF0c0JveFksIHBhZ2VXaWR0aCAtIChtYXJnaW4gKiAyKSwgc3RhdHNCb3hIZWlnaHQsIDMsIDMsICdGJyk7XG4gICAgXG4gICAgLy8gQWRkIHN0YXRzIHRleHRcbiAgICBkb2Muc2V0VGV4dENvbG9yKDgwLCA4MCwgODApO1xuICAgIGRvYy50ZXh0KGBUb3RhbCBNZW1iZXJzOiAke3NhZmVNZW1iZXJzLmxlbmd0aH0gfCBBcHByb3ZlZDogJHthcHByb3ZlZENvdW50fSB8IFBlbmRpbmc6ICR7cGVuZGluZ0NvdW50fSB8IFBhaWQ6ICR7cGFpZENvdW50fWAsXG4gICAgICBtYXJnaW4gKyA1LCBzdGF0c0JveFkgKyA4KTtcbiAgICBkb2MudGV4dChgQWN0aXZlOiAke2FjdGl2ZUNvdW50fSB8IENvbXBldGl0aW9uIFBhcnRpY2lwYW50czogJHtjb21wZXRpdGlvbnNDb3VudH0gfCBBYUdBIENoYWxsZW5nZSBQYXJ0aWNpcGFudHM6ICR7YWFnYUNvdW50fWAsXG4gICAgICBtYXJnaW4gKyA1LCBzdGF0c0JveFkgKyAxNik7XG5cbiAgICBzdGFydFkgKz0gc3RhdHNCb3hIZWlnaHQgKyAxMDtcblxuICAgIC8vIERldGVybWluZSBjb2x1bW5zIGJhc2VkIG9uIGV4cG9ydCB0eXBlXG4gICAgbGV0IGNvbHVtbnMgPSBbXTtcbiAgICBsZXQgcm93cyA9IFtdO1xuXG4gICAgLy8gQ29uZmlndXJlIGNvbHVtbnMgYW5kIGRhdGEgYmFzZWQgb24gZXhwb3J0IHR5cGVcbiAgICBzd2l0Y2ggKGV4cG9ydFR5cGUpIHtcbiAgICAgIGNhc2UgJ2FjdGl2ZSc6XG4gICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgIGNhc2UgJ2V4cGlyZWQnOlxuICAgICAgICBjb2x1bW5zID0gW1xuICAgICAgICAgIHsgaGVhZGVyOiAnRmlyc3QgTmFtZScsIGRhdGFLZXk6ICdmaXJzdF9uYW1lJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnU3VybmFtZScsIGRhdGFLZXk6ICdzdXJuYW1lJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnRW1haWwnLCBkYXRhS2V5OiAnZW1haWwnIH0sXG4gICAgICAgICAgeyBoZWFkZXI6ICdEYXRlIG9mIEJpcnRoJywgZGF0YUtleTogJ2RhdGVfb2ZfYmlydGgnIH0sXG4gICAgICAgICAgeyBoZWFkZXI6ICdTdGF0dXMnLCBkYXRhS2V5OiAnc3RhdHVzJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnUGF5bWVudCcsIGRhdGFLZXk6ICdwYXltZW50X3N0YXR1cycgfSxcbiAgICAgICAgICB7IGhlYWRlcjogJ0VBIE51bWJlcicsIGRhdGFLZXk6ICdlYV9udW1iZXInIH0sXG4gICAgICAgICAgeyBoZWFkZXI6ICdFeHBpcnkgRGF0ZScsIGRhdGFLZXk6ICdtZW1iZXJzaGlwX2V4cGlyeScgfVxuICAgICAgICBdO1xuICAgICAgICByb3dzID0gc2FmZU1lbWJlcnMubWFwKG0gPT4gKHtcbiAgICAgICAgICBmaXJzdF9uYW1lOiBtLmZpcnN0X25hbWUgfHwgJycsXG4gICAgICAgICAgc3VybmFtZTogbS5zdXJuYW1lIHx8ICcnLFxuICAgICAgICAgIGVtYWlsOiBtLmVtYWlsIHx8ICcnLFxuICAgICAgICAgIGRhdGVfb2ZfYmlydGg6IGZvcm1hdERhdGUobS5kYXRlX29mX2JpcnRoKSxcbiAgICAgICAgICBzdGF0dXM6IGZvcm1hdFN0YXR1cyhtLnN0YXR1cyB8fCAncGVuZGluZycpLFxuICAgICAgICAgIHBheW1lbnRfc3RhdHVzOiBtLnBheW1lbnRfc3RhdHVzID09PSAncGFpZCcgPyAnUGFpZCcgOiAnVW5wYWlkJyxcbiAgICAgICAgICBlYV9udW1iZXI6IG0uZWFfbnVtYmVyIHx8ICdOb3QgcmVnaXN0ZXJlZCcsXG4gICAgICAgICAgbWVtYmVyc2hpcF9leHBpcnk6IGZvcm1hdERhdGUobS5tZW1iZXJzaGlwX2V4cGlyeSlcbiAgICAgICAgfSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NvbXBldGl0aW9ucyc6XG4gICAgICAgIGNvbnN0IGNvbXBldGl0aW9uTWVtYmVycyA9IHNhZmVNZW1iZXJzLmZpbHRlcihtID0+IG0gJiYgbS5vcHRfaW5fY29tcGV0aXRpb25zKTtcbiAgICAgICAgY29sdW1ucyA9IFtcbiAgICAgICAgICB7IGhlYWRlcjogJ0ZpcnN0IE5hbWUnLCBkYXRhS2V5OiAnZmlyc3RfbmFtZScgfSxcbiAgICAgICAgICB7IGhlYWRlcjogJ1N1cm5hbWUnLCBkYXRhS2V5OiAnc3VybmFtZScgfSxcbiAgICAgICAgICB7IGhlYWRlcjogJ0VtYWlsJywgZGF0YUtleTogJ2VtYWlsJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnRGF0ZSBvZiBCaXJ0aCcsIGRhdGFLZXk6ICdkYXRlX29mX2JpcnRoJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnTWVtYmVyc2hpcCBTdGF0dXMnLCBkYXRhS2V5OiAnbWVtYmVyc2hpcF9zdGF0dXMnIH0sXG4gICAgICAgICAgeyBoZWFkZXI6ICdQYXltZW50IFN0YXR1cycsIGRhdGFLZXk6ICdwYXltZW50X3N0YXR1cycgfSxcbiAgICAgICAgICB7IGhlYWRlcjogJ0VBIE51bWJlcicsIGRhdGFLZXk6ICdlYV9udW1iZXInIH1cbiAgICAgICAgXTtcbiAgICAgICAgcm93cyA9IGNvbXBldGl0aW9uTWVtYmVycy5tYXAobSA9PiAoe1xuICAgICAgICAgIGZpcnN0X25hbWU6IG0uZmlyc3RfbmFtZSB8fCAnJyxcbiAgICAgICAgICBzdXJuYW1lOiBtLnN1cm5hbWUgfHwgJycsXG4gICAgICAgICAgZW1haWw6IG0uZW1haWwgfHwgJycsXG4gICAgICAgICAgZGF0ZV9vZl9iaXJ0aDogZm9ybWF0RGF0ZShtLmRhdGVfb2ZfYmlydGgpLFxuICAgICAgICAgIG1lbWJlcnNoaXBfc3RhdHVzOiBmb3JtYXRTdGF0dXMobS5tZW1iZXJzaGlwX3N0YXR1cyB8fCAncGVuZGluZycpLFxuICAgICAgICAgIHBheW1lbnRfc3RhdHVzOiBtLnBheW1lbnRfc3RhdHVzID09PSAncGFpZCcgPyAnUGFpZCcgOiAnVW5wYWlkJyxcbiAgICAgICAgICBlYV9udW1iZXI6IG0uZWFfbnVtYmVyIHx8ICdOb3QgcmVnaXN0ZXJlZCdcbiAgICAgICAgfSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FhZ2EnOlxuICAgICAgICBjb25zdCBhYWdhTWVtYmVycyA9IHNhZmVNZW1iZXJzLmZpbHRlcihtID0+IG0gJiYgbS5vcHRfaW5fYWFnYV9jaGFsbGVuZ2UpO1xuICAgICAgICBjb2x1bW5zID0gW1xuICAgICAgICAgIHsgaGVhZGVyOiAnRmlyc3QgTmFtZScsIGRhdGFLZXk6ICdmaXJzdF9uYW1lJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnU3VybmFtZScsIGRhdGFLZXk6ICdzdXJuYW1lJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnRW1haWwnLCBkYXRhS2V5OiAnZW1haWwnIH0sXG4gICAgICAgICAgeyBoZWFkZXI6ICdEYXRlIG9mIEJpcnRoJywgZGF0YUtleTogJ2RhdGVfb2ZfYmlydGgnIH0sXG4gICAgICAgICAgeyBoZWFkZXI6ICdNZW1iZXJzaGlwIFN0YXR1cycsIGRhdGFLZXk6ICdtZW1iZXJzaGlwX3N0YXR1cycgfSxcbiAgICAgICAgICB7IGhlYWRlcjogJ1BheW1lbnQgU3RhdHVzJywgZGF0YUtleTogJ3BheW1lbnRfc3RhdHVzJyB9XG4gICAgICAgIF07XG4gICAgICAgIHJvd3MgPSBhYWdhTWVtYmVycy5tYXAobSA9PiAoe1xuICAgICAgICAgIGZpcnN0X25hbWU6IG0uZmlyc3RfbmFtZSB8fCAnJyxcbiAgICAgICAgICBzdXJuYW1lOiBtLnN1cm5hbWUgfHwgJycsXG4gICAgICAgICAgZW1haWw6IG0uZW1haWwgfHwgJycsXG4gICAgICAgICAgZGF0ZV9vZl9iaXJ0aDogZm9ybWF0RGF0ZShtLmRhdGVfb2ZfYmlydGgpLFxuICAgICAgICAgIG1lbWJlcnNoaXBfc3RhdHVzOiBmb3JtYXRTdGF0dXMobS5tZW1iZXJzaGlwX3N0YXR1cyB8fCAncGVuZGluZycpLFxuICAgICAgICAgIHBheW1lbnRfc3RhdHVzOiBtLnBheW1lbnRfc3RhdHVzID09PSAncGFpZCcgPyAnUGFpZCcgOiAnVW5wYWlkJ1xuICAgICAgICB9KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb2x1bW5zID0gW1xuICAgICAgICAgIHsgaGVhZGVyOiAnRmlyc3QgTmFtZScsIGRhdGFLZXk6ICdmaXJzdF9uYW1lJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnU3VybmFtZScsIGRhdGFLZXk6ICdzdXJuYW1lJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnRW1haWwnLCBkYXRhS2V5OiAnZW1haWwnIH0sXG4gICAgICAgICAgeyBoZWFkZXI6ICdTdGF0dXMnLCBkYXRhS2V5OiAnc3RhdHVzJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnUGF5bWVudCcsIGRhdGFLZXk6ICdwYXltZW50X3N0YXR1cycgfVxuICAgICAgICBdO1xuICAgICAgICByb3dzID0gc2FmZU1lbWJlcnMubWFwKG0gPT4gKHtcbiAgICAgICAgICBmaXJzdF9uYW1lOiBtLmZpcnN0X25hbWUgfHwgJycsXG4gICAgICAgICAgc3VybmFtZTogbS5zdXJuYW1lIHx8ICcnLFxuICAgICAgICAgIGVtYWlsOiBtLmVtYWlsIHx8ICcnLFxuICAgICAgICAgIHN0YXR1czogZm9ybWF0U3RhdHVzKG0uc3RhdHVzIHx8ICdwZW5kaW5nJyksXG4gICAgICAgICAgcGF5bWVudF9zdGF0dXM6IG0ucGF5bWVudF9zdGF0dXMgPT09ICdwYWlkJyA/ICdQYWlkJyA6ICdVbnBhaWQnXG4gICAgICAgIH0pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gVGFibGVcbiAgICBhdXRvVGFibGUoZG9jLCB7XG4gICAgICBoZWFkOiBbY29sdW1ucy5tYXAoY29sID0+IGNvbC5oZWFkZXIpXSxcbiAgICAgIGJvZHk6IHJvd3MubWFwKHJvdyA9PiBjb2x1bW5zLm1hcChjb2wgPT4gcm93W2NvbC5kYXRhS2V5XSkpLFxuICAgICAgc3RhcnRZOiBzdGFydFksXG4gICAgICBtYXJnaW46IHsgbGVmdDogbWFyZ2luLCByaWdodDogbWFyZ2luIH0sXG4gICAgICBzdHlsZXM6IHtcbiAgICAgICAgZm9udFNpemU6IDksIC8vIFNsaWdodGx5IHNtYWxsZXIgZm9udCB0byBmaXQgbW9yZSBjb250ZW50XG4gICAgICAgIGNlbGxQYWRkaW5nOiAzLCAvLyBSZWR1Y2VkIHBhZGRpbmcgdG8gZml0IG1vcmUgY29udGVudFxuICAgICAgICB2YWxpZ246ICdtaWRkbGUnLFxuICAgICAgICBvdmVyZmxvdzogJ2VsbGlwc2l6ZScsIC8vIENoYW5nZWQgZnJvbSAnbGluZWJyZWFrJyB0byAnZWxsaXBzaXplJyB0byBwcmV2ZW50IHdyYXBwaW5nXG4gICAgICAgIHRleHRDb2xvcjogWzMwLCAzMCwgMzBdLFxuICAgICAgICBoYWxpZ246ICdsZWZ0JyxcbiAgICAgICAgbWluQ2VsbEhlaWdodDogMTAsXG4gICAgICAgIGxpbmVXaWR0aDogMC4xLFxuICAgICAgICBjZWxsV2lkdGg6ICd3cmFwJywgLy8gU2V0IGRlZmF1bHQgY2VsbCB3aWR0aCBiZWhhdmlvclxuICAgICAgfSxcbiAgICAgIGhlYWRTdHlsZXM6IHtcbiAgICAgICAgZmlsbENvbG9yOiBbMjU1LCAxMDIsIDBdLFxuICAgICAgICB0ZXh0Q29sb3I6IFsyNTUsIDI1NSwgMjU1XSxcbiAgICAgICAgZm9udFN0eWxlOiAnYm9sZCcsXG4gICAgICAgIGZvbnRTaXplOiAxMCwgLy8gU2xpZ2h0bHkgc21hbGxlciBmb250IGZvciBoZWFkZXJzXG4gICAgICAgIGhhbGlnbjogJ2xlZnQnLFxuICAgICAgICBjZWxsUGFkZGluZzogNCxcbiAgICAgIH0sXG4gICAgICBhbHRlcm5hdGVSb3dTdHlsZXM6IHsgZmlsbENvbG9yOiBbMjQ1LCAyNDUsIDI0NV0gfSxcbiAgICAgIGNvbHVtblN0eWxlczogZ2V0Q29sdW1uU3R5bGVzKGNvbHVtbnMpLFxuICAgICAgZGlkRHJhd1BhZ2U6IChkYXRhKSA9PiB7XG4gICAgICAgIC8vIEFkZCBoZWFkZXIgdG8gZWFjaCBwYWdlXG4gICAgICAgIGlmIChkYXRhLnBhZ2VOdW1iZXIgPiAxKSB7XG4gICAgICAgICAgYWRkQnJhbmRpbmcoZG9jLCBwYWdlV2lkdGgsIG1hcmdpbik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBmb290ZXIgdG8gZWFjaCBwYWdlXG4gICAgICAgIGFkZEZvb3Rlcihkb2MsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgZGF0YS5wYWdlTnVtYmVyLCBkb2MuZ2V0TnVtYmVyT2ZQYWdlcygpLCBtYXJnaW4pO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIFNhdmUgdGhlIFBERlxuICAgIGNvbnN0IGZpbGVuYW1lID0gYHNhZHJjX21lbWJlcnNfJHtleHBvcnRUeXBlfV8ke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdfS5wZGZgO1xuICAgIGRvYy5zYXZlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZmlsZW5hbWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignUERGIEV4cG9ydCBFcnJvciBEZXRhaWxzOicsIHsgXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJyxcbiAgICAgIHN0YWNrOiBlcnJvci5zdGFjayB8fCAnTm8gc3RhY2sgdHJhY2UnLFxuICAgICAgZXhwb3J0VHlwZTogZXhwb3J0VHlwZSB8fCAndW5rbm93bidcbiAgICB9KTtcbiAgICB0aHJvdyBlcnJvcjsgLy8gUmUtdGhyb3cgdG8gYWxsb3cgdGhlIGNhbGxpbmcgZnVuY3Rpb24gdG8gaGFuZGxlIGl0XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGJyYW5kaW5nIGVsZW1lbnRzIHRvIHRoZSBQREZcbiAqL1xuZnVuY3Rpb24gYWRkQnJhbmRpbmcoZG9jLCBwYWdlV2lkdGgsIG1hcmdpbikge1xuICB0cnkge1xuICAgIC8vIEhlYWRlciBiYWNrZ3JvdW5kXG4gICAgZG9jLnNldEZpbGxDb2xvcigyNTUsIDEwMiwgMCk7XG4gICAgZG9jLnJlY3QoMCwgMCwgcGFnZVdpZHRoLCBtYXJnaW4gKyAxMCwgJ0YnKTtcbiAgICBcbiAgICAvLyBUaXRsZVxuICAgIGRvYy5zZXRGb250U2l6ZSgyNCk7XG4gICAgZG9jLnNldFRleHRDb2xvcigyNTUsIDI1NSwgMjU1KTtcbiAgICBkb2Muc2V0Rm9udCgnaGVsdmV0aWNhJywgJ2JvbGQnKTtcbiAgICBkb2MudGV4dCgnU0FEUkMgTWVtYmVyc2hpcCcsIHBhZ2VXaWR0aCAvIDIsIG1hcmdpbiwgeyBhbGlnbjogJ2NlbnRlcicgfSk7XG4gICAgXG4gICAgLy8gRGF0ZSBsaW5lXG4gICAgZG9jLnNldERyYXdDb2xvcigyNTUsIDI1NSwgMjU1KTtcbiAgICBkb2Muc2V0TGluZVdpZHRoKDAuNSk7XG4gICAgZG9jLmxpbmUobWFyZ2luLCBtYXJnaW4gKyA0LCBwYWdlV2lkdGggLSBtYXJnaW4sIG1hcmdpbiArIDQpO1xuICAgIFxuICAgIC8vIEV4cG9ydCBkYXRlXG4gICAgZG9jLnNldEZvbnRTaXplKDExKTtcbiAgICBkb2Muc2V0VGV4dENvbG9yKDI1NSwgMjU1LCAyNTUpO1xuICAgIGRvYy5zZXRGb250KCdoZWx2ZXRpY2EnLCAnbm9ybWFsJyk7XG4gICAgZG9jLnRleHQoYEV4cG9ydCBEYXRlOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1HQicpfWAsIHBhZ2VXaWR0aCAvIDIsIG1hcmdpbiArIDEwLCB7IGFsaWduOiAnY2VudGVyJyB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBhZGRCcmFuZGluZzonLCBlcnJvcik7XG4gICAgLy8gQ29udGludWUgZXhlY3V0aW9uIGV2ZW4gaWYgYnJhbmRpbmcgZmFpbHNcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYSBmb290ZXIgdG8gZWFjaCBwYWdlXG4gKi9cbmZ1bmN0aW9uIGFkZEZvb3Rlcihkb2MsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgcGFnZU51bWJlciwgdG90YWxQYWdlcywgbWFyZ2luKSB7XG4gIHRyeSB7XG4gICAgLy8gRm9vdGVyIGxpbmVcbiAgICBkb2Muc2V0RHJhd0NvbG9yKDIwMCwgMjAwLCAyMDApO1xuICAgIGRvYy5zZXRMaW5lV2lkdGgoMC41KTtcbiAgICBkb2MubGluZShtYXJnaW4sIHBhZ2VIZWlnaHQgLSAxNSwgcGFnZVdpZHRoIC0gbWFyZ2luLCBwYWdlSGVpZ2h0IC0gMTUpO1xuICAgIFxuICAgIC8vIFBhZ2UgbnVtYmVycyBhbmQgY29uZmlkZW50aWFsaXR5IG5vdGljZVxuICAgIGRvYy5zZXRGb250U2l6ZSg4KTtcbiAgICBkb2Muc2V0VGV4dENvbG9yKDEyMCwgMTIwLCAxMjApO1xuICAgIGRvYy5zZXRGb250KCdoZWx2ZXRpY2EnLCAnbm9ybWFsJyk7XG4gICAgZG9jLnRleHQoXG4gICAgICBgU2tlZ25lc3MgJiBEaXN0cmljdCBSdW5uaW5nIENsdWIgLSBDb25maWRlbnRpYWwgLSBQYWdlICR7cGFnZU51bWJlcn0gb2YgJHt0b3RhbFBhZ2VzfWAsXG4gICAgICBwYWdlV2lkdGggLyAyLFxuICAgICAgcGFnZUhlaWdodCAtIDgsXG4gICAgICB7IGFsaWduOiAnY2VudGVyJyB9XG4gICAgKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBhZGRGb290ZXI6JywgZXJyb3IpO1xuICAgIC8vIENvbnRpbnVlIGV4ZWN1dGlvbiBldmVuIGlmIGZvb3RlciBmYWlsc1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhcHByb3ByaWF0ZSBjb2x1bW4gc3R5bGVzIGJhc2VkIG9uIHRoZSBjb2x1bW5zIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGdldENvbHVtblN0eWxlcyhjb2x1bW5zKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3R5bGVzID0ge307XG4gICAgXG4gICAgLy8gU2V0IHdpZHRoIGZvciBlYWNoIGNvbHVtbiB0eXBlIC0gYWRqdXN0ZWQgdG8gcHJldmVudCB3cmFwcGluZ1xuICAgIGNvbHVtbnMuZm9yRWFjaCgoY29sLCBpbmRleCkgPT4ge1xuICAgICAgc3dpdGNoKGNvbC5kYXRhS2V5KSB7XG4gICAgICAgIGNhc2UgJ2ZpcnN0X25hbWUnOlxuICAgICAgICAgIHN0eWxlc1tpbmRleF0gPSB7IGNlbGxXaWR0aDogMzAsIG92ZXJmbG93OiAnZWxsaXBzaXplJyB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdXJuYW1lJzpcbiAgICAgICAgICBzdHlsZXNbaW5kZXhdID0geyBjZWxsV2lkdGg6IDMwLCBvdmVyZmxvdzogJ2VsbGlwc2l6ZScgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZW1haWwnOlxuICAgICAgICAgIHN0eWxlc1tpbmRleF0gPSB7IGNlbGxXaWR0aDogNjAsIG92ZXJmbG93OiAnZWxsaXBzaXplJyB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkYXRlX29mX2JpcnRoJzpcbiAgICAgICAgY2FzZSAnbWVtYmVyc2hpcF9leHBpcnknOlxuICAgICAgICAgIHN0eWxlc1tpbmRleF0gPSB7IGNlbGxXaWR0aDogMjIsIGhhbGlnbjogJ2NlbnRlcicsIG92ZXJmbG93OiAnZWxsaXBzaXplJyB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdGF0dXMnOlxuICAgICAgICBjYXNlICdtZW1iZXJzaGlwX3N0YXR1cyc6XG4gICAgICAgICAgc3R5bGVzW2luZGV4XSA9IHsgY2VsbFdpZHRoOiAyMiwgaGFsaWduOiAnY2VudGVyJywgb3ZlcmZsb3c6ICdlbGxpcHNpemUnIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3BheW1lbnRfc3RhdHVzJzpcbiAgICAgICAgICBzdHlsZXNbaW5kZXhdID0geyBjZWxsV2lkdGg6IDE4LCBoYWxpZ246ICdjZW50ZXInLCBvdmVyZmxvdzogJ2VsbGlwc2l6ZScgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZWFfbnVtYmVyJzpcbiAgICAgICAgICBzdHlsZXNbaW5kZXhdID0geyBjZWxsV2lkdGg6IDI1LCBoYWxpZ246ICdjZW50ZXInLCBvdmVyZmxvdzogJ2VsbGlwc2l6ZScgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzdHlsZXNbaW5kZXhdID0geyBjZWxsV2lkdGg6ICdhdXRvJywgb3ZlcmZsb3c6ICdlbGxpcHNpemUnIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRDb2x1bW5TdHlsZXM6JywgZXJyb3IpO1xuICAgIHJldHVybiB7fTsgLy8gUmV0dXJuIGVtcHR5IG9iamVjdCBhcyBmYWxsYmFja1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0cyBhIGRhdGUgc3RyaW5nIHRvIEREL01NL1lZWVlcbiAqL1xuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlU3RyaW5nKSB7XG4gIGlmICghZGF0ZVN0cmluZykgcmV0dXJuICdOb3Qgc2V0JztcbiAgXG4gIHRyeSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHJpbmcpO1xuICAgIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHJldHVybiAnSW52YWxpZCBkYXRlJztcbiAgICBcbiAgICByZXR1cm4gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLUdCJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKCdEYXRlIGZvcm1hdHRpbmcgZXJyb3I6JywgZSk7XG4gICAgcmV0dXJuIGRhdGVTdHJpbmcgfHwgJ05vdCBzZXQnO1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0cyBzdGF0dXMgd2l0aCBwcm9wZXIgY2FwaXRhbGl6YXRpb25cbiAqL1xuZnVuY3Rpb24gZm9ybWF0U3RhdHVzKHN0YXR1cykge1xuICBpZiAoIXN0YXR1cykgcmV0dXJuICdQZW5kaW5nJztcbiAgXG4gIHRyeSB7XG4gICAgcmV0dXJuIHN0YXR1cy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0YXR1cy5zbGljZSgxKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1N0YXR1cyBmb3JtYXR0aW5nIGVycm9yOicsIGUpO1xuICAgIHJldHVybiBzdGF0dXMgfHwgJ1BlbmRpbmcnO1xuICB9XG59XG4iXSwibmFtZXMiOlsianNQREYiLCJhdXRvVGFibGUiLCJleHBvcnRNZW1iZXJzVG9QREYiLCJtZW1iZXJzIiwiZXhwb3J0VHlwZSIsImRvYyIsIm9yaWVudGF0aW9uIiwidW5pdCIsImZvcm1hdCIsInBhZ2VXaWR0aCIsImludGVybmFsIiwicGFnZVNpemUiLCJnZXRXaWR0aCIsInBhZ2VIZWlnaHQiLCJnZXRIZWlnaHQiLCJtYXJnaW4iLCJjdXJyZW50RGF0ZSIsIkRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJhZGRCcmFuZGluZyIsInNldFByb3BlcnRpZXMiLCJ0aXRsZSIsInN1YmplY3QiLCJhdXRob3IiLCJjcmVhdG9yIiwic3RhcnRZIiwic2V0Rm9udCIsInNldEZvbnRTaXplIiwic2V0VGV4dENvbG9yIiwidGV4dCIsImFsaWduIiwic2FmZU1lbWJlcnMiLCJBcnJheSIsImlzQXJyYXkiLCJhcHByb3ZlZENvdW50IiwiZmlsdGVyIiwibSIsInN0YXR1cyIsImxlbmd0aCIsInBlbmRpbmdDb3VudCIsInBhaWRDb3VudCIsInBheW1lbnRfc3RhdHVzIiwiY29tcGV0aXRpb25zQ291bnQiLCJvcHRfaW5fY29tcGV0aXRpb25zIiwiYWFnYUNvdW50Iiwib3B0X2luX2FhZ2FfY2hhbGxlbmdlIiwiYWN0aXZlQ291bnQiLCJtZW1iZXJzaGlwX3N0YXR1cyIsInN0YXRzQm94WSIsInN0YXRzQm94SGVpZ2h0Iiwic2V0RmlsbENvbG9yIiwicm91bmRlZFJlY3QiLCJjb2x1bW5zIiwicm93cyIsImhlYWRlciIsImRhdGFLZXkiLCJtYXAiLCJmaXJzdF9uYW1lIiwic3VybmFtZSIsImVtYWlsIiwiZGF0ZV9vZl9iaXJ0aCIsImZvcm1hdERhdGUiLCJmb3JtYXRTdGF0dXMiLCJlYV9udW1iZXIiLCJtZW1iZXJzaGlwX2V4cGlyeSIsImNvbXBldGl0aW9uTWVtYmVycyIsImFhZ2FNZW1iZXJzIiwiaGVhZCIsImNvbCIsImJvZHkiLCJyb3ciLCJsZWZ0IiwicmlnaHQiLCJzdHlsZXMiLCJmb250U2l6ZSIsImNlbGxQYWRkaW5nIiwidmFsaWduIiwib3ZlcmZsb3ciLCJ0ZXh0Q29sb3IiLCJoYWxpZ24iLCJtaW5DZWxsSGVpZ2h0IiwibGluZVdpZHRoIiwiY2VsbFdpZHRoIiwiaGVhZFN0eWxlcyIsImZpbGxDb2xvciIsImZvbnRTdHlsZSIsImFsdGVybmF0ZVJvd1N0eWxlcyIsImNvbHVtblN0eWxlcyIsImdldENvbHVtblN0eWxlcyIsImRpZERyYXdQYWdlIiwiZGF0YSIsInBhZ2VOdW1iZXIiLCJhZGRGb290ZXIiLCJnZXROdW1iZXJPZlBhZ2VzIiwiZmlsZW5hbWUiLCJ0b0lTT1N0cmluZyIsInNwbGl0Iiwic2F2ZSIsImVycm9yIiwiY29uc29sZSIsIm1lc3NhZ2UiLCJzdGFjayIsInJlY3QiLCJzZXREcmF3Q29sb3IiLCJzZXRMaW5lV2lkdGgiLCJsaW5lIiwidG90YWxQYWdlcyIsImZvckVhY2giLCJpbmRleCIsImRhdGVTdHJpbmciLCJkYXRlIiwiaXNOYU4iLCJnZXRUaW1lIiwiZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/pdfExportHelper.js\n"));

/***/ })

});