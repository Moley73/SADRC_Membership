"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/admin",{

/***/ "./lib/pdfExportHelper.js":
/*!********************************!*\
  !*** ./lib/pdfExportHelper.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportMembersToPDF: function() { return /* binding */ exportMembersToPDF; }\n/* harmony export */ });\n/* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jspdf */ \"./node_modules/jspdf/dist/jspdf.es.min.js\");\n/* harmony import */ var jspdf_autotable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jspdf-autotable */ \"./node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.mjs\");\n// PDF Export Helper\n\n\n/**\n * Exports the given members array to a styled PDF file.\n * @param {Array} members - Array of member objects to export.\n * @param {String} exportType - Type of export ('full', 'competitions', 'aaga', or 'summary')\n */ function exportMembersToPDF(members) {\n    let exportType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"summary\";\n    // Create new document with landscape orientation for better table display\n    const doc = new jspdf__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        orientation: \"landscape\",\n        unit: \"mm\",\n        format: \"a4\"\n    });\n    const pageWidth = doc.internal.pageSize.getWidth();\n    const pageHeight = doc.internal.pageSize.getHeight();\n    const margin1 = 16;\n    const currentDate = new Date().toLocaleDateString(\"en-GB\"); // Format as DD/MM/YYYY\n    // Add club logo/branding\n    addBranding(doc, pageWidth, margin1);\n    // Set document properties\n    doc.setProperties({\n        title: \"SADRC Membership Export\",\n        subject: \"Membership Data\",\n        author: \"SADRC Admin System\",\n        creator: \"SADRC Membership App\"\n    });\n    // Add title and subtitle\n    let title = \"\";\n    let startY = margin1 + 30; // Adjusted for logo\n    // Configure columns and data based on export type\n    switch(exportType){\n        case \"active\":\n            title = \"Active Members\";\n            break;\n        case \"pending\":\n            title = \"Pending Members\";\n            break;\n        case \"expired\":\n            title = \"Expired Members\";\n            break;\n        case \"competitions\":\n            title = \"Club Competitions Participants\";\n            break;\n        case \"aaga\":\n            title = \"AaGA Challenge Participants\";\n            break;\n        case \"summary\":\n        default:\n            title = \"Membership Summary\";\n            break;\n    }\n    // Section title\n    doc.setFont(\"helvetica\", \"bold\");\n    doc.setFontSize(18);\n    doc.setTextColor(0, 0, 0);\n    doc.text(title, pageWidth / 2, startY, {\n        align: \"center\"\n    });\n    // Stats summary\n    startY += 10;\n    doc.setFont(\"helvetica\", \"normal\");\n    doc.setFontSize(10);\n    const approvedCount = members.filter((m)=>m.status === \"approved\").length;\n    const pendingCount = members.filter((m)=>!m.status || m.status === \"pending\").length;\n    const paidCount = members.filter((m)=>m.payment_status === \"paid\").length;\n    const competitionsCount = members.filter((m)=>m.opt_in_competitions).length;\n    const aagaCount = members.filter((m)=>m.opt_in_aaga_challenge).length;\n    const activeCount = members.filter((m)=>m.membership_status === \"active\").length;\n    // Create a stats box\n    const statsBoxY = startY;\n    const statsBoxHeight = 20;\n    // Draw stats box background\n    doc.setFillColor(245, 245, 245);\n    doc.roundedRect(margin1, statsBoxY, pageWidth - margin1 * 2, statsBoxHeight, 3, 3, \"F\");\n    // Add stats text\n    doc.setTextColor(80, 80, 80);\n    doc.text(\"Total Members: \".concat(members.length, \" | Approved: \").concat(approvedCount, \" | Pending: \").concat(pendingCount, \" | Paid: \").concat(paidCount), margin1 + 5, statsBoxY + 8);\n    doc.text(\"Active: \".concat(activeCount, \" | Competition Participants: \").concat(competitionsCount, \" | AaGA Challenge Participants: \").concat(aagaCount), margin1 + 5, statsBoxY + 16);\n    startY += statsBoxHeight + 10;\n    // Determine columns based on export type\n    let columns = [];\n    let rows = [];\n    // Configure columns and data based on export type\n    switch(exportType){\n        case \"active\":\n        case \"pending\":\n        case \"expired\":\n            columns = [\n                {\n                    header: \"First Name\",\n                    dataKey: \"first_name\"\n                },\n                {\n                    header: \"Surname\",\n                    dataKey: \"surname\"\n                },\n                {\n                    header: \"Email\",\n                    dataKey: \"email\"\n                },\n                {\n                    header: \"Date of Birth\",\n                    dataKey: \"date_of_birth\"\n                },\n                {\n                    header: \"Status\",\n                    dataKey: \"status\"\n                },\n                {\n                    header: \"Payment\",\n                    dataKey: \"payment_status\"\n                },\n                {\n                    header: \"EA Number\",\n                    dataKey: \"ea_number\"\n                },\n                {\n                    header: \"Expiry Date\",\n                    dataKey: \"membership_expiry\"\n                }\n            ];\n            rows = members.map((m)=>({\n                    first_name: m.first_name || \"\",\n                    surname: m.surname || \"\",\n                    email: m.email || \"\",\n                    date_of_birth: formatDate(m.date_of_birth),\n                    status: formatStatus(m.status || \"pending\"),\n                    payment_status: m.payment_status === \"paid\" ? \"Paid\" : \"Unpaid\",\n                    ea_number: m.ea_number || \"Not registered\",\n                    membership_expiry: formatDate(m.membership_expiry)\n                }));\n            break;\n        case \"competitions\":\n            const competitionMembers = members.filter((m)=>m.opt_in_competitions);\n            columns = [\n                {\n                    header: \"First Name\",\n                    dataKey: \"first_name\"\n                },\n                {\n                    header: \"Surname\",\n                    dataKey: \"surname\"\n                },\n                {\n                    header: \"Email\",\n                    dataKey: \"email\"\n                },\n                {\n                    header: \"Date of Birth\",\n                    dataKey: \"date_of_birth\"\n                },\n                {\n                    header: \"Membership Status\",\n                    dataKey: \"membership_status\"\n                },\n                {\n                    header: \"Payment Status\",\n                    dataKey: \"payment_status\"\n                },\n                {\n                    header: \"EA Number\",\n                    dataKey: \"ea_number\"\n                }\n            ];\n            rows = competitionMembers.map((m)=>({\n                    first_name: m.first_name || \"\",\n                    surname: m.surname || \"\",\n                    email: m.email || \"\",\n                    date_of_birth: formatDate(m.date_of_birth),\n                    membership_status: formatStatus(m.membership_status || \"pending\"),\n                    payment_status: m.payment_status === \"paid\" ? \"Paid\" : \"Unpaid\",\n                    ea_number: m.ea_number || \"Not registered\"\n                }));\n            break;\n        case \"aaga\":\n            const aagaMembers = members.filter((m)=>m.opt_in_aaga_challenge);\n            columns = [\n                {\n                    header: \"First Name\",\n                    dataKey: \"first_name\"\n                },\n                {\n                    header: \"Surname\",\n                    dataKey: \"surname\"\n                },\n                {\n                    header: \"Email\",\n                    dataKey: \"email\"\n                },\n                {\n                    header: \"Date of Birth\",\n                    dataKey: \"date_of_birth\"\n                },\n                {\n                    header: \"Membership Status\",\n                    dataKey: \"membership_status\"\n                },\n                {\n                    header: \"Payment Status\",\n                    dataKey: \"payment_status\"\n                }\n            ];\n            rows = aagaMembers.map((m)=>({\n                    first_name: m.first_name || \"\",\n                    surname: m.surname || \"\",\n                    email: m.email || \"\",\n                    date_of_birth: formatDate(m.date_of_birth),\n                    membership_status: formatStatus(m.membership_status || \"pending\"),\n                    payment_status: m.payment_status === \"paid\" ? \"Paid\" : \"Unpaid\"\n                }));\n            break;\n        case \"summary\":\n        default:\n            columns = [\n                {\n                    header: \"First Name\",\n                    dataKey: \"first_name\"\n                },\n                {\n                    header: \"Surname\",\n                    dataKey: \"surname\"\n                },\n                {\n                    header: \"Email\",\n                    dataKey: \"email\"\n                },\n                {\n                    header: \"Status\",\n                    dataKey: \"status\"\n                },\n                {\n                    header: \"Payment\",\n                    dataKey: \"payment_status\"\n                }\n            ];\n            rows = members.map((m)=>({\n                    first_name: m.first_name || \"\",\n                    surname: m.surname || \"\",\n                    email: m.email || \"\",\n                    status: formatStatus(m.status || \"pending\"),\n                    payment_status: m.payment_status === \"paid\" ? \"Paid\" : \"Unpaid\"\n                }));\n            break;\n    }\n    // Table\n    (0,jspdf_autotable__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(doc, {\n        head: [\n            columns.map((col)=>col.header)\n        ],\n        body: rows.map((row)=>columns.map((col)=>row[col.dataKey])),\n        startY: startY,\n        margin: {\n            left: margin1,\n            right: margin1\n        },\n        styles: {\n            fontSize: 10,\n            cellPadding: 4,\n            valign: \"middle\",\n            overflow: \"linebreak\",\n            textColor: [\n                30,\n                30,\n                30\n            ],\n            halign: \"left\",\n            minCellHeight: 10,\n            lineWidth: 0.1\n        },\n        headStyles: {\n            fillColor: [\n                255,\n                102,\n                0\n            ],\n            textColor: [\n                255,\n                255,\n                255\n            ],\n            fontStyle: \"bold\",\n            fontSize: 11,\n            halign: \"left\",\n            cellPadding: 5\n        },\n        alternateRowStyles: {\n            fillColor: [\n                245,\n                245,\n                245\n            ]\n        },\n        columnStyles: getColumnStyles(columns),\n        didDrawPage: (data)=>{\n            // Add header to each page\n            if (data.pageNumber > 1) {\n                addBranding(doc, pageWidth, margin1);\n            }\n            // Add footer to each page\n            addFooter(doc, pageWidth, pageHeight, data.pageNumber, doc.getNumberOfPages());\n        }\n    });\n    // Save the PDF\n    const filename = \"sadrc_members_\".concat(exportType, \"_\").concat(new Date().toISOString().split(\"T\")[0], \".pdf\");\n    doc.save(filename);\n    return filename;\n}\n/**\n * Adds branding elements to the PDF\n */ function addBranding(doc, pageWidth, margin1) {\n    // Header background\n    doc.setFillColor(255, 102, 0);\n    doc.rect(0, 0, pageWidth, margin1 + 10, \"F\");\n    // Title\n    doc.setFontSize(24);\n    doc.setTextColor(255, 255, 255);\n    doc.setFont(\"helvetica\", \"bold\");\n    doc.text(\"SADRC Membership\", pageWidth / 2, margin1, {\n        align: \"center\"\n    });\n    // Date line\n    doc.setDrawColor(255, 255, 255);\n    doc.setLineWidth(0.5);\n    doc.line(margin1, margin1 + 4, pageWidth - margin1, margin1 + 4);\n    // Export date\n    doc.setFontSize(11);\n    doc.setTextColor(255, 255, 255);\n    doc.setFont(\"helvetica\", \"normal\");\n    doc.text(\"Export Date: \".concat(new Date().toLocaleDateString(\"en-GB\")), pageWidth / 2, margin1 + 10, {\n        align: \"center\"\n    });\n}\n/**\n * Adds a footer to each page\n */ function addFooter(doc, pageWidth, pageHeight, pageNumber, totalPages) {\n    // Footer line\n    doc.setDrawColor(200, 200, 200);\n    doc.setLineWidth(0.5);\n    doc.line(margin, pageHeight - 15, pageWidth - margin, pageHeight - 15);\n    // Page numbers and confidentiality notice\n    doc.setFontSize(8);\n    doc.setTextColor(120, 120, 120);\n    doc.setFont(\"helvetica\", \"normal\");\n    doc.text(\"Skegness & District Running Club - Confidential - Page \".concat(pageNumber, \" of \").concat(totalPages), pageWidth / 2, pageHeight - 8, {\n        align: \"center\"\n    });\n}\n/**\n * Returns appropriate column styles based on the columns array\n */ function getColumnStyles(columns) {\n    const styles = {};\n    // Set width for each column type\n    columns.forEach((col, index)=>{\n        switch(col.dataKey){\n            case \"first_name\":\n            case \"surname\":\n                styles[index] = {\n                    cellWidth: 25\n                };\n                break;\n            case \"email\":\n                styles[index] = {\n                    cellWidth: 50\n                };\n                break;\n            case \"date_of_birth\":\n            case \"membership_expiry\":\n                styles[index] = {\n                    cellWidth: 25,\n                    halign: \"center\"\n                };\n                break;\n            case \"status\":\n            case \"membership_status\":\n            case \"payment_status\":\n                styles[index] = {\n                    cellWidth: 25,\n                    halign: \"center\"\n                };\n                break;\n            case \"ea_number\":\n                styles[index] = {\n                    cellWidth: 30,\n                    halign: \"center\"\n                };\n                break;\n            default:\n                styles[index] = {\n                    cellWidth: \"auto\"\n                };\n        }\n    });\n    return styles;\n}\n/**\n * Formats a date string to DD/MM/YYYY\n */ function formatDate(dateString) {\n    if (!dateString) return \"Not set\";\n    try {\n        const date = new Date(dateString);\n        if (isNaN(date.getTime())) return \"Invalid date\";\n        return date.toLocaleDateString(\"en-GB\");\n    } catch (e) {\n        return dateString;\n    }\n}\n/**\n * Formats status with proper capitalization\n */ function formatStatus(status) {\n    if (!status) return \"Pending\";\n    return status.charAt(0).toUpperCase() + status.slice(1);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFLRSxPQUFPLEtBQUssT0FBTztRQUVsQyxPQUFPRixLQUFLckYsa0JBQWtCLENBQUM7SUFDakMsRUFBRSxPQUFPd0YsR0FBRztRQUNWLE9BQU9KO0lBQ1Q7QUFDRjtBQUVBOztDQUVDLEdBQ0QsU0FBUzNDLGFBQWF6QixNQUFNO0lBQzFCLElBQUksQ0FBQ0EsUUFBUSxPQUFPO0lBRXBCLE9BQU9BLE9BQU95RSxNQUFNLENBQUMsR0FBR0MsV0FBVyxLQUFLMUUsT0FBTzJFLEtBQUssQ0FBQztBQUN2RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvcGRmRXhwb3J0SGVscGVyLmpzP2MwODEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUERGIEV4cG9ydCBIZWxwZXJcbmltcG9ydCBqc1BERiBmcm9tICdqc3BkZic7XG5pbXBvcnQgYXV0b1RhYmxlIGZyb20gJ2pzcGRmLWF1dG90YWJsZSc7XG5cbi8qKlxuICogRXhwb3J0cyB0aGUgZ2l2ZW4gbWVtYmVycyBhcnJheSB0byBhIHN0eWxlZCBQREYgZmlsZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG1lbWJlcnMgLSBBcnJheSBvZiBtZW1iZXIgb2JqZWN0cyB0byBleHBvcnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwb3J0VHlwZSAtIFR5cGUgb2YgZXhwb3J0ICgnZnVsbCcsICdjb21wZXRpdGlvbnMnLCAnYWFnYScsIG9yICdzdW1tYXJ5JylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cG9ydE1lbWJlcnNUb1BERihtZW1iZXJzLCBleHBvcnRUeXBlID0gJ3N1bW1hcnknKSB7XG4gIC8vIENyZWF0ZSBuZXcgZG9jdW1lbnQgd2l0aCBsYW5kc2NhcGUgb3JpZW50YXRpb24gZm9yIGJldHRlciB0YWJsZSBkaXNwbGF5XG4gIGNvbnN0IGRvYyA9IG5ldyBqc1BERih7IG9yaWVudGF0aW9uOiAnbGFuZHNjYXBlJywgdW5pdDogJ21tJywgZm9ybWF0OiAnYTQnIH0pO1xuICBjb25zdCBwYWdlV2lkdGggPSBkb2MuaW50ZXJuYWwucGFnZVNpemUuZ2V0V2lkdGgoKTtcbiAgY29uc3QgcGFnZUhlaWdodCA9IGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS5nZXRIZWlnaHQoKTtcbiAgY29uc3QgbWFyZ2luID0gMTY7XG4gIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLUdCJyk7IC8vIEZvcm1hdCBhcyBERC9NTS9ZWVlZXG4gIFxuICAvLyBBZGQgY2x1YiBsb2dvL2JyYW5kaW5nXG4gIGFkZEJyYW5kaW5nKGRvYywgcGFnZVdpZHRoLCBtYXJnaW4pO1xuXG4gIC8vIFNldCBkb2N1bWVudCBwcm9wZXJ0aWVzXG4gIGRvYy5zZXRQcm9wZXJ0aWVzKHtcbiAgICB0aXRsZTogJ1NBRFJDIE1lbWJlcnNoaXAgRXhwb3J0JyxcbiAgICBzdWJqZWN0OiAnTWVtYmVyc2hpcCBEYXRhJyxcbiAgICBhdXRob3I6ICdTQURSQyBBZG1pbiBTeXN0ZW0nLFxuICAgIGNyZWF0b3I6ICdTQURSQyBNZW1iZXJzaGlwIEFwcCdcbiAgfSk7XG5cbiAgLy8gQWRkIHRpdGxlIGFuZCBzdWJ0aXRsZVxuICBsZXQgdGl0bGUgPSAnJztcbiAgbGV0IHN0YXJ0WSA9IG1hcmdpbiArIDMwOyAvLyBBZGp1c3RlZCBmb3IgbG9nb1xuXG4gIC8vIENvbmZpZ3VyZSBjb2x1bW5zIGFuZCBkYXRhIGJhc2VkIG9uIGV4cG9ydCB0eXBlXG4gIHN3aXRjaCAoZXhwb3J0VHlwZSkge1xuICAgIGNhc2UgJ2FjdGl2ZSc6XG4gICAgICB0aXRsZSA9ICdBY3RpdmUgTWVtYmVycyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgIHRpdGxlID0gJ1BlbmRpbmcgTWVtYmVycyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdleHBpcmVkJzpcbiAgICAgIHRpdGxlID0gJ0V4cGlyZWQgTWVtYmVycyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb21wZXRpdGlvbnMnOlxuICAgICAgdGl0bGUgPSAnQ2x1YiBDb21wZXRpdGlvbnMgUGFydGljaXBhbnRzJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FhZ2EnOlxuICAgICAgdGl0bGUgPSAnQWFHQSBDaGFsbGVuZ2UgUGFydGljaXBhbnRzJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgIGRlZmF1bHQ6XG4gICAgICB0aXRsZSA9ICdNZW1iZXJzaGlwIFN1bW1hcnknO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICAvLyBTZWN0aW9uIHRpdGxlXG4gIGRvYy5zZXRGb250KCdoZWx2ZXRpY2EnLCAnYm9sZCcpO1xuICBkb2Muc2V0Rm9udFNpemUoMTgpO1xuICBkb2Muc2V0VGV4dENvbG9yKDAsIDAsIDApO1xuICBkb2MudGV4dCh0aXRsZSwgcGFnZVdpZHRoIC8gMiwgc3RhcnRZLCB7IGFsaWduOiAnY2VudGVyJyB9KTtcblxuICAvLyBTdGF0cyBzdW1tYXJ5XG4gIHN0YXJ0WSArPSAxMDtcbiAgZG9jLnNldEZvbnQoJ2hlbHZldGljYScsICdub3JtYWwnKTtcbiAgZG9jLnNldEZvbnRTaXplKDEwKTtcbiAgY29uc3QgYXBwcm92ZWRDb3VudCA9IG1lbWJlcnMuZmlsdGVyKG0gPT4gbS5zdGF0dXMgPT09ICdhcHByb3ZlZCcpLmxlbmd0aDtcbiAgY29uc3QgcGVuZGluZ0NvdW50ID0gbWVtYmVycy5maWx0ZXIobSA9PiAhbS5zdGF0dXMgfHwgbS5zdGF0dXMgPT09ICdwZW5kaW5nJykubGVuZ3RoO1xuICBjb25zdCBwYWlkQ291bnQgPSBtZW1iZXJzLmZpbHRlcihtID0+IG0ucGF5bWVudF9zdGF0dXMgPT09ICdwYWlkJykubGVuZ3RoO1xuICBjb25zdCBjb21wZXRpdGlvbnNDb3VudCA9IG1lbWJlcnMuZmlsdGVyKG0gPT4gbS5vcHRfaW5fY29tcGV0aXRpb25zKS5sZW5ndGg7XG4gIGNvbnN0IGFhZ2FDb3VudCA9IG1lbWJlcnMuZmlsdGVyKG0gPT4gbS5vcHRfaW5fYWFnYV9jaGFsbGVuZ2UpLmxlbmd0aDtcbiAgY29uc3QgYWN0aXZlQ291bnQgPSBtZW1iZXJzLmZpbHRlcihtID0+IG0ubWVtYmVyc2hpcF9zdGF0dXMgPT09ICdhY3RpdmUnKS5sZW5ndGg7XG4gIFxuICAvLyBDcmVhdGUgYSBzdGF0cyBib3hcbiAgY29uc3Qgc3RhdHNCb3hZID0gc3RhcnRZO1xuICBjb25zdCBzdGF0c0JveEhlaWdodCA9IDIwO1xuICBcbiAgLy8gRHJhdyBzdGF0cyBib3ggYmFja2dyb3VuZFxuICBkb2Muc2V0RmlsbENvbG9yKDI0NSwgMjQ1LCAyNDUpO1xuICBkb2Mucm91bmRlZFJlY3QobWFyZ2luLCBzdGF0c0JveFksIHBhZ2VXaWR0aCAtIChtYXJnaW4gKiAyKSwgc3RhdHNCb3hIZWlnaHQsIDMsIDMsICdGJyk7XG4gIFxuICAvLyBBZGQgc3RhdHMgdGV4dFxuICBkb2Muc2V0VGV4dENvbG9yKDgwLCA4MCwgODApO1xuICBkb2MudGV4dChgVG90YWwgTWVtYmVyczogJHttZW1iZXJzLmxlbmd0aH0gfCBBcHByb3ZlZDogJHthcHByb3ZlZENvdW50fSB8IFBlbmRpbmc6ICR7cGVuZGluZ0NvdW50fSB8IFBhaWQ6ICR7cGFpZENvdW50fWAsXG4gICAgbWFyZ2luICsgNSwgc3RhdHNCb3hZICsgOCk7XG4gIGRvYy50ZXh0KGBBY3RpdmU6ICR7YWN0aXZlQ291bnR9IHwgQ29tcGV0aXRpb24gUGFydGljaXBhbnRzOiAke2NvbXBldGl0aW9uc0NvdW50fSB8IEFhR0EgQ2hhbGxlbmdlIFBhcnRpY2lwYW50czogJHthYWdhQ291bnR9YCxcbiAgICBtYXJnaW4gKyA1LCBzdGF0c0JveFkgKyAxNik7XG5cbiAgc3RhcnRZICs9IHN0YXRzQm94SGVpZ2h0ICsgMTA7XG5cbiAgLy8gRGV0ZXJtaW5lIGNvbHVtbnMgYmFzZWQgb24gZXhwb3J0IHR5cGVcbiAgbGV0IGNvbHVtbnMgPSBbXTtcbiAgbGV0IHJvd3MgPSBbXTtcblxuICAvLyBDb25maWd1cmUgY29sdW1ucyBhbmQgZGF0YSBiYXNlZCBvbiBleHBvcnQgdHlwZVxuICBzd2l0Y2ggKGV4cG9ydFR5cGUpIHtcbiAgICBjYXNlICdhY3RpdmUnOlxuICAgIGNhc2UgJ3BlbmRpbmcnOlxuICAgIGNhc2UgJ2V4cGlyZWQnOlxuICAgICAgY29sdW1ucyA9IFtcbiAgICAgICAgeyBoZWFkZXI6ICdGaXJzdCBOYW1lJywgZGF0YUtleTogJ2ZpcnN0X25hbWUnIH0sXG4gICAgICAgIHsgaGVhZGVyOiAnU3VybmFtZScsIGRhdGFLZXk6ICdzdXJuYW1lJyB9LFxuICAgICAgICB7IGhlYWRlcjogJ0VtYWlsJywgZGF0YUtleTogJ2VtYWlsJyB9LFxuICAgICAgICB7IGhlYWRlcjogJ0RhdGUgb2YgQmlydGgnLCBkYXRhS2V5OiAnZGF0ZV9vZl9iaXJ0aCcgfSxcbiAgICAgICAgeyBoZWFkZXI6ICdTdGF0dXMnLCBkYXRhS2V5OiAnc3RhdHVzJyB9LFxuICAgICAgICB7IGhlYWRlcjogJ1BheW1lbnQnLCBkYXRhS2V5OiAncGF5bWVudF9zdGF0dXMnIH0sXG4gICAgICAgIHsgaGVhZGVyOiAnRUEgTnVtYmVyJywgZGF0YUtleTogJ2VhX251bWJlcicgfSxcbiAgICAgICAgeyBoZWFkZXI6ICdFeHBpcnkgRGF0ZScsIGRhdGFLZXk6ICdtZW1iZXJzaGlwX2V4cGlyeScgfVxuICAgICAgXTtcbiAgICAgIHJvd3MgPSBtZW1iZXJzLm1hcChtID0+ICh7XG4gICAgICAgIGZpcnN0X25hbWU6IG0uZmlyc3RfbmFtZSB8fCAnJyxcbiAgICAgICAgc3VybmFtZTogbS5zdXJuYW1lIHx8ICcnLFxuICAgICAgICBlbWFpbDogbS5lbWFpbCB8fCAnJyxcbiAgICAgICAgZGF0ZV9vZl9iaXJ0aDogZm9ybWF0RGF0ZShtLmRhdGVfb2ZfYmlydGgpLFxuICAgICAgICBzdGF0dXM6IGZvcm1hdFN0YXR1cyhtLnN0YXR1cyB8fCAncGVuZGluZycpLFxuICAgICAgICBwYXltZW50X3N0YXR1czogbS5wYXltZW50X3N0YXR1cyA9PT0gJ3BhaWQnID8gJ1BhaWQnIDogJ1VucGFpZCcsXG4gICAgICAgIGVhX251bWJlcjogbS5lYV9udW1iZXIgfHwgJ05vdCByZWdpc3RlcmVkJyxcbiAgICAgICAgbWVtYmVyc2hpcF9leHBpcnk6IGZvcm1hdERhdGUobS5tZW1iZXJzaGlwX2V4cGlyeSlcbiAgICAgIH0pKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NvbXBldGl0aW9ucyc6XG4gICAgICBjb25zdCBjb21wZXRpdGlvbk1lbWJlcnMgPSBtZW1iZXJzLmZpbHRlcihtID0+IG0ub3B0X2luX2NvbXBldGl0aW9ucyk7XG4gICAgICBjb2x1bW5zID0gW1xuICAgICAgICB7IGhlYWRlcjogJ0ZpcnN0IE5hbWUnLCBkYXRhS2V5OiAnZmlyc3RfbmFtZScgfSxcbiAgICAgICAgeyBoZWFkZXI6ICdTdXJuYW1lJywgZGF0YUtleTogJ3N1cm5hbWUnIH0sXG4gICAgICAgIHsgaGVhZGVyOiAnRW1haWwnLCBkYXRhS2V5OiAnZW1haWwnIH0sXG4gICAgICAgIHsgaGVhZGVyOiAnRGF0ZSBvZiBCaXJ0aCcsIGRhdGFLZXk6ICdkYXRlX29mX2JpcnRoJyB9LFxuICAgICAgICB7IGhlYWRlcjogJ01lbWJlcnNoaXAgU3RhdHVzJywgZGF0YUtleTogJ21lbWJlcnNoaXBfc3RhdHVzJyB9LFxuICAgICAgICB7IGhlYWRlcjogJ1BheW1lbnQgU3RhdHVzJywgZGF0YUtleTogJ3BheW1lbnRfc3RhdHVzJyB9LFxuICAgICAgICB7IGhlYWRlcjogJ0VBIE51bWJlcicsIGRhdGFLZXk6ICdlYV9udW1iZXInIH1cbiAgICAgIF07XG4gICAgICByb3dzID0gY29tcGV0aXRpb25NZW1iZXJzLm1hcChtID0+ICh7XG4gICAgICAgIGZpcnN0X25hbWU6IG0uZmlyc3RfbmFtZSB8fCAnJyxcbiAgICAgICAgc3VybmFtZTogbS5zdXJuYW1lIHx8ICcnLFxuICAgICAgICBlbWFpbDogbS5lbWFpbCB8fCAnJyxcbiAgICAgICAgZGF0ZV9vZl9iaXJ0aDogZm9ybWF0RGF0ZShtLmRhdGVfb2ZfYmlydGgpLFxuICAgICAgICBtZW1iZXJzaGlwX3N0YXR1czogZm9ybWF0U3RhdHVzKG0ubWVtYmVyc2hpcF9zdGF0dXMgfHwgJ3BlbmRpbmcnKSxcbiAgICAgICAgcGF5bWVudF9zdGF0dXM6IG0ucGF5bWVudF9zdGF0dXMgPT09ICdwYWlkJyA/ICdQYWlkJyA6ICdVbnBhaWQnLFxuICAgICAgICBlYV9udW1iZXI6IG0uZWFfbnVtYmVyIHx8ICdOb3QgcmVnaXN0ZXJlZCdcbiAgICAgIH0pKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FhZ2EnOlxuICAgICAgY29uc3QgYWFnYU1lbWJlcnMgPSBtZW1iZXJzLmZpbHRlcihtID0+IG0ub3B0X2luX2FhZ2FfY2hhbGxlbmdlKTtcbiAgICAgIGNvbHVtbnMgPSBbXG4gICAgICAgIHsgaGVhZGVyOiAnRmlyc3QgTmFtZScsIGRhdGFLZXk6ICdmaXJzdF9uYW1lJyB9LFxuICAgICAgICB7IGhlYWRlcjogJ1N1cm5hbWUnLCBkYXRhS2V5OiAnc3VybmFtZScgfSxcbiAgICAgICAgeyBoZWFkZXI6ICdFbWFpbCcsIGRhdGFLZXk6ICdlbWFpbCcgfSxcbiAgICAgICAgeyBoZWFkZXI6ICdEYXRlIG9mIEJpcnRoJywgZGF0YUtleTogJ2RhdGVfb2ZfYmlydGgnIH0sXG4gICAgICAgIHsgaGVhZGVyOiAnTWVtYmVyc2hpcCBTdGF0dXMnLCBkYXRhS2V5OiAnbWVtYmVyc2hpcF9zdGF0dXMnIH0sXG4gICAgICAgIHsgaGVhZGVyOiAnUGF5bWVudCBTdGF0dXMnLCBkYXRhS2V5OiAncGF5bWVudF9zdGF0dXMnIH1cbiAgICAgIF07XG4gICAgICByb3dzID0gYWFnYU1lbWJlcnMubWFwKG0gPT4gKHtcbiAgICAgICAgZmlyc3RfbmFtZTogbS5maXJzdF9uYW1lIHx8ICcnLFxuICAgICAgICBzdXJuYW1lOiBtLnN1cm5hbWUgfHwgJycsXG4gICAgICAgIGVtYWlsOiBtLmVtYWlsIHx8ICcnLFxuICAgICAgICBkYXRlX29mX2JpcnRoOiBmb3JtYXREYXRlKG0uZGF0ZV9vZl9iaXJ0aCksXG4gICAgICAgIG1lbWJlcnNoaXBfc3RhdHVzOiBmb3JtYXRTdGF0dXMobS5tZW1iZXJzaGlwX3N0YXR1cyB8fCAncGVuZGluZycpLFxuICAgICAgICBwYXltZW50X3N0YXR1czogbS5wYXltZW50X3N0YXR1cyA9PT0gJ3BhaWQnID8gJ1BhaWQnIDogJ1VucGFpZCdcbiAgICAgIH0pKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgIGRlZmF1bHQ6XG4gICAgICBjb2x1bW5zID0gW1xuICAgICAgICB7IGhlYWRlcjogJ0ZpcnN0IE5hbWUnLCBkYXRhS2V5OiAnZmlyc3RfbmFtZScgfSxcbiAgICAgICAgeyBoZWFkZXI6ICdTdXJuYW1lJywgZGF0YUtleTogJ3N1cm5hbWUnIH0sXG4gICAgICAgIHsgaGVhZGVyOiAnRW1haWwnLCBkYXRhS2V5OiAnZW1haWwnIH0sXG4gICAgICAgIHsgaGVhZGVyOiAnU3RhdHVzJywgZGF0YUtleTogJ3N0YXR1cycgfSxcbiAgICAgICAgeyBoZWFkZXI6ICdQYXltZW50JywgZGF0YUtleTogJ3BheW1lbnRfc3RhdHVzJyB9XG4gICAgICBdO1xuICAgICAgcm93cyA9IG1lbWJlcnMubWFwKG0gPT4gKHtcbiAgICAgICAgZmlyc3RfbmFtZTogbS5maXJzdF9uYW1lIHx8ICcnLFxuICAgICAgICBzdXJuYW1lOiBtLnN1cm5hbWUgfHwgJycsXG4gICAgICAgIGVtYWlsOiBtLmVtYWlsIHx8ICcnLFxuICAgICAgICBzdGF0dXM6IGZvcm1hdFN0YXR1cyhtLnN0YXR1cyB8fCAncGVuZGluZycpLFxuICAgICAgICBwYXltZW50X3N0YXR1czogbS5wYXltZW50X3N0YXR1cyA9PT0gJ3BhaWQnID8gJ1BhaWQnIDogJ1VucGFpZCdcbiAgICAgIH0pKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gVGFibGVcbiAgYXV0b1RhYmxlKGRvYywge1xuICAgIGhlYWQ6IFtjb2x1bW5zLm1hcChjb2wgPT4gY29sLmhlYWRlcildLFxuICAgIGJvZHk6IHJvd3MubWFwKHJvdyA9PiBjb2x1bW5zLm1hcChjb2wgPT4gcm93W2NvbC5kYXRhS2V5XSkpLFxuICAgIHN0YXJ0WTogc3RhcnRZLFxuICAgIG1hcmdpbjogeyBsZWZ0OiBtYXJnaW4sIHJpZ2h0OiBtYXJnaW4gfSxcbiAgICBzdHlsZXM6IHtcbiAgICAgIGZvbnRTaXplOiAxMCxcbiAgICAgIGNlbGxQYWRkaW5nOiA0LFxuICAgICAgdmFsaWduOiAnbWlkZGxlJyxcbiAgICAgIG92ZXJmbG93OiAnbGluZWJyZWFrJyxcbiAgICAgIHRleHRDb2xvcjogWzMwLCAzMCwgMzBdLFxuICAgICAgaGFsaWduOiAnbGVmdCcsXG4gICAgICBtaW5DZWxsSGVpZ2h0OiAxMCxcbiAgICAgIGxpbmVXaWR0aDogMC4xLFxuICAgIH0sXG4gICAgaGVhZFN0eWxlczoge1xuICAgICAgZmlsbENvbG9yOiBbMjU1LCAxMDIsIDBdLFxuICAgICAgdGV4dENvbG9yOiBbMjU1LCAyNTUsIDI1NV0sXG4gICAgICBmb250U3R5bGU6ICdib2xkJyxcbiAgICAgIGZvbnRTaXplOiAxMSxcbiAgICAgIGhhbGlnbjogJ2xlZnQnLFxuICAgICAgY2VsbFBhZGRpbmc6IDUsXG4gICAgfSxcbiAgICBhbHRlcm5hdGVSb3dTdHlsZXM6IHsgZmlsbENvbG9yOiBbMjQ1LCAyNDUsIDI0NV0gfSxcbiAgICBjb2x1bW5TdHlsZXM6IGdldENvbHVtblN0eWxlcyhjb2x1bW5zKSxcbiAgICBkaWREcmF3UGFnZTogKGRhdGEpID0+IHtcbiAgICAgIC8vIEFkZCBoZWFkZXIgdG8gZWFjaCBwYWdlXG4gICAgICBpZiAoZGF0YS5wYWdlTnVtYmVyID4gMSkge1xuICAgICAgICBhZGRCcmFuZGluZyhkb2MsIHBhZ2VXaWR0aCwgbWFyZ2luKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWRkIGZvb3RlciB0byBlYWNoIHBhZ2VcbiAgICAgIGFkZEZvb3Rlcihkb2MsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgZGF0YS5wYWdlTnVtYmVyLCBkb2MuZ2V0TnVtYmVyT2ZQYWdlcygpKTtcbiAgICB9LFxuICB9KTtcblxuICAvLyBTYXZlIHRoZSBQREZcbiAgY29uc3QgZmlsZW5hbWUgPSBgc2FkcmNfbWVtYmVyc18ke2V4cG9ydFR5cGV9XyR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF19LnBkZmA7XG4gIGRvYy5zYXZlKGZpbGVuYW1lKTtcbiAgcmV0dXJuIGZpbGVuYW1lO1xufVxuXG4vKipcbiAqIEFkZHMgYnJhbmRpbmcgZWxlbWVudHMgdG8gdGhlIFBERlxuICovXG5mdW5jdGlvbiBhZGRCcmFuZGluZyhkb2MsIHBhZ2VXaWR0aCwgbWFyZ2luKSB7XG4gIC8vIEhlYWRlciBiYWNrZ3JvdW5kXG4gIGRvYy5zZXRGaWxsQ29sb3IoMjU1LCAxMDIsIDApO1xuICBkb2MucmVjdCgwLCAwLCBwYWdlV2lkdGgsIG1hcmdpbiArIDEwLCAnRicpO1xuICBcbiAgLy8gVGl0bGVcbiAgZG9jLnNldEZvbnRTaXplKDI0KTtcbiAgZG9jLnNldFRleHRDb2xvcigyNTUsIDI1NSwgMjU1KTtcbiAgZG9jLnNldEZvbnQoJ2hlbHZldGljYScsICdib2xkJyk7XG4gIGRvYy50ZXh0KCdTQURSQyBNZW1iZXJzaGlwJywgcGFnZVdpZHRoIC8gMiwgbWFyZ2luLCB7IGFsaWduOiAnY2VudGVyJyB9KTtcbiAgXG4gIC8vIERhdGUgbGluZVxuICBkb2Muc2V0RHJhd0NvbG9yKDI1NSwgMjU1LCAyNTUpO1xuICBkb2Muc2V0TGluZVdpZHRoKDAuNSk7XG4gIGRvYy5saW5lKG1hcmdpbiwgbWFyZ2luICsgNCwgcGFnZVdpZHRoIC0gbWFyZ2luLCBtYXJnaW4gKyA0KTtcbiAgXG4gIC8vIEV4cG9ydCBkYXRlXG4gIGRvYy5zZXRGb250U2l6ZSgxMSk7XG4gIGRvYy5zZXRUZXh0Q29sb3IoMjU1LCAyNTUsIDI1NSk7XG4gIGRvYy5zZXRGb250KCdoZWx2ZXRpY2EnLCAnbm9ybWFsJyk7XG4gIGRvYy50ZXh0KGBFeHBvcnQgRGF0ZTogJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tR0InKX1gLCBwYWdlV2lkdGggLyAyLCBtYXJnaW4gKyAxMCwgeyBhbGlnbjogJ2NlbnRlcicgfSk7XG59XG5cbi8qKlxuICogQWRkcyBhIGZvb3RlciB0byBlYWNoIHBhZ2VcbiAqL1xuZnVuY3Rpb24gYWRkRm9vdGVyKGRvYywgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCBwYWdlTnVtYmVyLCB0b3RhbFBhZ2VzKSB7XG4gIC8vIEZvb3RlciBsaW5lXG4gIGRvYy5zZXREcmF3Q29sb3IoMjAwLCAyMDAsIDIwMCk7XG4gIGRvYy5zZXRMaW5lV2lkdGgoMC41KTtcbiAgZG9jLmxpbmUobWFyZ2luLCBwYWdlSGVpZ2h0IC0gMTUsIHBhZ2VXaWR0aCAtIG1hcmdpbiwgcGFnZUhlaWdodCAtIDE1KTtcbiAgXG4gIC8vIFBhZ2UgbnVtYmVycyBhbmQgY29uZmlkZW50aWFsaXR5IG5vdGljZVxuICBkb2Muc2V0Rm9udFNpemUoOCk7XG4gIGRvYy5zZXRUZXh0Q29sb3IoMTIwLCAxMjAsIDEyMCk7XG4gIGRvYy5zZXRGb250KCdoZWx2ZXRpY2EnLCAnbm9ybWFsJyk7XG4gIGRvYy50ZXh0KFxuICAgIGBTa2VnbmVzcyAmIERpc3RyaWN0IFJ1bm5pbmcgQ2x1YiAtIENvbmZpZGVudGlhbCAtIFBhZ2UgJHtwYWdlTnVtYmVyfSBvZiAke3RvdGFsUGFnZXN9YCxcbiAgICBwYWdlV2lkdGggLyAyLFxuICAgIHBhZ2VIZWlnaHQgLSA4LFxuICAgIHsgYWxpZ246ICdjZW50ZXInIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFwcHJvcHJpYXRlIGNvbHVtbiBzdHlsZXMgYmFzZWQgb24gdGhlIGNvbHVtbnMgYXJyYXlcbiAqL1xuZnVuY3Rpb24gZ2V0Q29sdW1uU3R5bGVzKGNvbHVtbnMpIHtcbiAgY29uc3Qgc3R5bGVzID0ge307XG4gIFxuICAvLyBTZXQgd2lkdGggZm9yIGVhY2ggY29sdW1uIHR5cGVcbiAgY29sdW1ucy5mb3JFYWNoKChjb2wsIGluZGV4KSA9PiB7XG4gICAgc3dpdGNoKGNvbC5kYXRhS2V5KSB7XG4gICAgICBjYXNlICdmaXJzdF9uYW1lJzpcbiAgICAgIGNhc2UgJ3N1cm5hbWUnOlxuICAgICAgICBzdHlsZXNbaW5kZXhdID0geyBjZWxsV2lkdGg6IDI1IH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZW1haWwnOlxuICAgICAgICBzdHlsZXNbaW5kZXhdID0geyBjZWxsV2lkdGg6IDUwIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGF0ZV9vZl9iaXJ0aCc6XG4gICAgICBjYXNlICdtZW1iZXJzaGlwX2V4cGlyeSc6XG4gICAgICAgIHN0eWxlc1tpbmRleF0gPSB7IGNlbGxXaWR0aDogMjUsIGhhbGlnbjogJ2NlbnRlcicgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdGF0dXMnOlxuICAgICAgY2FzZSAnbWVtYmVyc2hpcF9zdGF0dXMnOlxuICAgICAgY2FzZSAncGF5bWVudF9zdGF0dXMnOlxuICAgICAgICBzdHlsZXNbaW5kZXhdID0geyBjZWxsV2lkdGg6IDI1LCBoYWxpZ246ICdjZW50ZXInIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZWFfbnVtYmVyJzpcbiAgICAgICAgc3R5bGVzW2luZGV4XSA9IHsgY2VsbFdpZHRoOiAzMCwgaGFsaWduOiAnY2VudGVyJyB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN0eWxlc1tpbmRleF0gPSB7IGNlbGxXaWR0aDogJ2F1dG8nIH07XG4gICAgfVxuICB9KTtcbiAgXG4gIHJldHVybiBzdHlsZXM7XG59XG5cbi8qKlxuICogRm9ybWF0cyBhIGRhdGUgc3RyaW5nIHRvIEREL01NL1lZWVlcbiAqL1xuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlU3RyaW5nKSB7XG4gIGlmICghZGF0ZVN0cmluZykgcmV0dXJuICdOb3Qgc2V0JztcbiAgXG4gIHRyeSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHJpbmcpO1xuICAgIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHJldHVybiAnSW52YWxpZCBkYXRlJztcbiAgICBcbiAgICByZXR1cm4gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLUdCJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZGF0ZVN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIEZvcm1hdHMgc3RhdHVzIHdpdGggcHJvcGVyIGNhcGl0YWxpemF0aW9uXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFN0YXR1cyhzdGF0dXMpIHtcbiAgaWYgKCFzdGF0dXMpIHJldHVybiAnUGVuZGluZyc7XG4gIFxuICByZXR1cm4gc3RhdHVzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RhdHVzLnNsaWNlKDEpO1xufVxuIl0sIm5hbWVzIjpbImpzUERGIiwiYXV0b1RhYmxlIiwiZXhwb3J0TWVtYmVyc1RvUERGIiwibWVtYmVycyIsImV4cG9ydFR5cGUiLCJkb2MiLCJvcmllbnRhdGlvbiIsInVuaXQiLCJmb3JtYXQiLCJwYWdlV2lkdGgiLCJpbnRlcm5hbCIsInBhZ2VTaXplIiwiZ2V0V2lkdGgiLCJwYWdlSGVpZ2h0IiwiZ2V0SGVpZ2h0IiwibWFyZ2luIiwiY3VycmVudERhdGUiLCJEYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwiYWRkQnJhbmRpbmciLCJzZXRQcm9wZXJ0aWVzIiwidGl0bGUiLCJzdWJqZWN0IiwiYXV0aG9yIiwiY3JlYXRvciIsInN0YXJ0WSIsInNldEZvbnQiLCJzZXRGb250U2l6ZSIsInNldFRleHRDb2xvciIsInRleHQiLCJhbGlnbiIsImFwcHJvdmVkQ291bnQiLCJmaWx0ZXIiLCJtIiwic3RhdHVzIiwibGVuZ3RoIiwicGVuZGluZ0NvdW50IiwicGFpZENvdW50IiwicGF5bWVudF9zdGF0dXMiLCJjb21wZXRpdGlvbnNDb3VudCIsIm9wdF9pbl9jb21wZXRpdGlvbnMiLCJhYWdhQ291bnQiLCJvcHRfaW5fYWFnYV9jaGFsbGVuZ2UiLCJhY3RpdmVDb3VudCIsIm1lbWJlcnNoaXBfc3RhdHVzIiwic3RhdHNCb3hZIiwic3RhdHNCb3hIZWlnaHQiLCJzZXRGaWxsQ29sb3IiLCJyb3VuZGVkUmVjdCIsImNvbHVtbnMiLCJyb3dzIiwiaGVhZGVyIiwiZGF0YUtleSIsIm1hcCIsImZpcnN0X25hbWUiLCJzdXJuYW1lIiwiZW1haWwiLCJkYXRlX29mX2JpcnRoIiwiZm9ybWF0RGF0ZSIsImZvcm1hdFN0YXR1cyIsImVhX251bWJlciIsIm1lbWJlcnNoaXBfZXhwaXJ5IiwiY29tcGV0aXRpb25NZW1iZXJzIiwiYWFnYU1lbWJlcnMiLCJoZWFkIiwiY29sIiwiYm9keSIsInJvdyIsImxlZnQiLCJyaWdodCIsInN0eWxlcyIsImZvbnRTaXplIiwiY2VsbFBhZGRpbmciLCJ2YWxpZ24iLCJvdmVyZmxvdyIsInRleHRDb2xvciIsImhhbGlnbiIsIm1pbkNlbGxIZWlnaHQiLCJsaW5lV2lkdGgiLCJoZWFkU3R5bGVzIiwiZmlsbENvbG9yIiwiZm9udFN0eWxlIiwiYWx0ZXJuYXRlUm93U3R5bGVzIiwiY29sdW1uU3R5bGVzIiwiZ2V0Q29sdW1uU3R5bGVzIiwiZGlkRHJhd1BhZ2UiLCJkYXRhIiwicGFnZU51bWJlciIsImFkZEZvb3RlciIsImdldE51bWJlck9mUGFnZXMiLCJmaWxlbmFtZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJzYXZlIiwicmVjdCIsInNldERyYXdDb2xvciIsInNldExpbmVXaWR0aCIsImxpbmUiLCJ0b3RhbFBhZ2VzIiwiZm9yRWFjaCIsImluZGV4IiwiY2VsbFdpZHRoIiwiZGF0ZVN0cmluZyIsImRhdGUiLCJpc05hTiIsImdldFRpbWUiLCJlIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/pdfExportHelper.js\n"));

/***/ })

});