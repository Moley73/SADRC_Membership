"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./lib/supabaseClient.js":
/*!*******************************!*\
  !*** ./lib/supabaseClient.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   debugAuthState: function() { return /* binding */ debugAuthState; },\n/* harmony export */   getAuthToken: function() { return /* binding */ getAuthToken; },\n/* harmony export */   handleAuthError: function() { return /* binding */ handleAuthError; },\n/* harmony export */   isAdmin: function() { return /* binding */ isAdmin; },\n/* harmony export */   isLoggedIn: function() { return /* binding */ isLoggedIn; },\n/* harmony export */   refreshSession: function() { return /* binding */ refreshSession; },\n/* harmony export */   safeGetSession: function() { return /* binding */ safeGetSession; },\n/* harmony export */   supabase: function() { return /* binding */ supabase; },\n/* harmony export */   supabaseAdmin: function() { return /* binding */ supabaseAdmin; },\n/* harmony export */   testTableAccess: function() { return /* binding */ testTableAccess; },\n/* harmony export */   withServiceRole: function() { return /* binding */ withServiceRole; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\nconst supabaseUrl = \"https://wylflyzcsmkckzjdvsqc.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Ind5bGZseXpjc21rY2t6amR2c3FjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ3MTMzNDgsImV4cCI6MjA2MDI4OTM0OH0.9y6kBuwd1emWuseV6tv9BgtmSgB8a9UUb15n0n6UL0w\";\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n// Create a standard client with the user's session\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n    auth: {\n        persistSession: true,\n        autoRefreshToken: true,\n        detectSessionInUrl: true,\n        storageKey: \"sadrc-membership-auth\",\n        storage: {\n            getItem: (key)=>{\n                if (false) {}\n                return JSON.parse(window.localStorage.getItem(key));\n            },\n            setItem: (key, value)=>{\n                if (true) {\n                    window.localStorage.setItem(key, JSON.stringify(value));\n                }\n            },\n            removeItem: (key)=>{\n                if (true) {\n                    window.localStorage.removeItem(key);\n                }\n            }\n        }\n    }\n});\n// Create a service role client for admin operations\nconst supabaseAdmin = supabaseServiceKey ? (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseServiceKey, {\n    auth: {\n        autoRefreshToken: false,\n        persistSession: false\n    }\n}) : null;\n// Helper function to get the current session token\nconst getAuthToken = async ()=>{\n    try {\n        var _data_session;\n        const { data } = await supabase.auth.getSession();\n        return (data === null || data === void 0 ? void 0 : (_data_session = data.session) === null || _data_session === void 0 ? void 0 : _data_session.access_token) || null;\n    } catch (error) {\n        console.error(\"Error getting auth token:\", error);\n        return null;\n    }\n};\n// Helper function to check if user is logged in\nconst isLoggedIn = async ()=>{\n    try {\n        const { data } = await supabase.auth.getSession();\n        return !!(data === null || data === void 0 ? void 0 : data.session);\n    } catch (error) {\n        console.error(\"Error checking login status:\", error);\n        return false;\n    }\n};\n// Helper function to check if user is admin\nconst isAdmin = async ()=>{\n    try {\n        const { data: sessionData } = await supabase.auth.getSession();\n        if (!(sessionData === null || sessionData === void 0 ? void 0 : sessionData.session)) return false;\n        const { data } = await supabase.from(\"admin_list\").select(\"role\").eq(\"email\", sessionData.session.user.email).maybeSingle();\n        return !!data;\n    } catch (error) {\n        console.error(\"Error checking admin status:\", error);\n        return false;\n    }\n};\n// Force a session refresh\nconst refreshSession = async ()=>{\n    try {\n        const { data, error } = await supabase.auth.refreshSession();\n        if (error) throw error;\n        return data === null || data === void 0 ? void 0 : data.session;\n    } catch (error) {\n        console.error(\"Error refreshing session:\", error);\n        return null;\n    }\n};\n// Helper function to safely use the admin client\nconst withServiceRole = async (operation)=>{\n    if (!supabaseAdmin) {\n        console.error(\"Service role key not available. Falling back to regular client.\");\n        return operation(supabase);\n    }\n    try {\n        return await operation(supabaseAdmin);\n    } catch (error) {\n        console.error(\"Error using service role client:\", error);\n        // Fallback to regular client if service role fails\n        return operation(supabase);\n    }\n};\n// Add a custom error handler for auth errors\nconst handleAuthError = (error)=>{\n    if ((error === null || error === void 0 ? void 0 : error.name) === \"AuthSessionMissingError\") {\n        console.log(\"Session missing, redirecting to login\");\n        // Clear any local storage items that might be causing issues\n        if (true) {\n            localStorage.removeItem(\"sadrc-membership-auth\");\n            localStorage.removeItem(\"supabase.auth.token\");\n        }\n        return true; // Indicates this was an auth error that was handled\n    }\n    return false; // Not handled\n};\n// Helper to safely get the current session\nconst safeGetSession = async ()=>{\n    try {\n        var _data_session;\n        const { data, error } = await supabase.auth.getSession();\n        if (error) {\n            handleAuthError(error);\n            return {\n                session: null,\n                user: null\n            };\n        }\n        return {\n            session: (data === null || data === void 0 ? void 0 : data.session) || null,\n            user: (data === null || data === void 0 ? void 0 : (_data_session = data.session) === null || _data_session === void 0 ? void 0 : _data_session.user) || null\n        };\n    } catch (err) {\n        console.error(\"Unexpected error getting session:\", err);\n        handleAuthError(err);\n        return {\n            session: null,\n            user: null\n        };\n    }\n};\n// Debug function to log auth state and session details\nconst debugAuthState = async ()=>{\n    try {\n        var _sessionData_session, _userData_user, _userData_user1;\n        const { data: sessionData, error: sessionError } = await supabase.auth.getSession();\n        const { data: userData, error: userError } = await supabase.auth.getUser();\n        console.log(\"====== AUTH DEBUG INFO ======\");\n        console.log(\"Session exists:\", !!(sessionData === null || sessionData === void 0 ? void 0 : sessionData.session));\n        console.log(\"JWT exists:\", !!(sessionData === null || sessionData === void 0 ? void 0 : (_sessionData_session = sessionData.session) === null || _sessionData_session === void 0 ? void 0 : _sessionData_session.access_token));\n        console.log(\"User exists:\", !!(userData === null || userData === void 0 ? void 0 : userData.user));\n        if (userData === null || userData === void 0 ? void 0 : userData.user) {\n            console.log(\"User email:\", userData.user.email);\n            console.log(\"User ID:\", userData.user.id);\n        }\n        if (sessionError) {\n            console.error(\"Session error:\", sessionError);\n        }\n        if (userError) {\n            console.error(\"User error:\", userError);\n        }\n        return {\n            hasSession: !!(sessionData === null || sessionData === void 0 ? void 0 : sessionData.session),\n            hasUser: !!(userData === null || userData === void 0 ? void 0 : userData.user),\n            userEmail: userData === null || userData === void 0 ? void 0 : (_userData_user = userData.user) === null || _userData_user === void 0 ? void 0 : _userData_user.email,\n            userId: userData === null || userData === void 0 ? void 0 : (_userData_user1 = userData.user) === null || _userData_user1 === void 0 ? void 0 : _userData_user1.id,\n            sessionError,\n            userError\n        };\n    } catch (err) {\n        console.error(\"Error in debugAuthState:\", err);\n        return {\n            hasSession: false,\n            hasUser: false,\n            error: err.message\n        };\n    }\n};\n// Debug function to test RLS permissions on specific tables\nconst testTableAccess = async function(tableName) {\n    let email = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    try {\n        const query = supabase.from(tableName).select(\"*\");\n        // If email provided, try to filter by it\n        if (email) {\n            query.eq(\"email\", email);\n        }\n        // Limit to just one row for testing\n        query.limit(1);\n        // Execute with timeout\n        const timeoutPromise = new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Query to \".concat(tableName, \" timed out\"))), 5000));\n        const { data, error } = await Promise.race([\n            query,\n            timeoutPromise\n        ]);\n        console.log(\"==== \".concat(tableName.toUpperCase(), \" ACCESS TEST ====\"));\n        console.log(\"Query successful:\", !error);\n        console.log(\"Data found:\", !!data && data.length > 0);\n        if (error) {\n            console.error(\"Error accessing \".concat(tableName, \":\"), error);\n        }\n        return {\n            success: !error,\n            hasData: !!data && data.length > 0,\n            data: data,\n            error: error\n        };\n    } catch (err) {\n        console.error(\"Error testing access to \".concat(tableName, \":\"), err);\n        return {\n            success: false,\n            error: err.message\n        };\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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V0FBVyxJQUFHO1FBQzVDeEMsUUFBUWUsR0FBRyxDQUFDLHFCQUFxQixDQUFDaEI7UUFDbENDLFFBQVFlLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQ3BCLFFBQVFBLEtBQUs4QyxNQUFNLEdBQUc7UUFFbkQsSUFBSTFDLE9BQU87WUFDVEMsUUFBUUQsS0FBSyxDQUFDLG1CQUE2QixPQUFWK0IsV0FBVSxNQUFJL0I7UUFDakQ7UUFFQSxPQUFPO1lBQ0wyQyxTQUFTLENBQUMzQztZQUNWNEMsU0FBUyxDQUFDLENBQUNoRCxRQUFRQSxLQUFLOEMsTUFBTSxHQUFHO1lBQ2pDOUMsTUFBTUE7WUFDTkksT0FBT0E7UUFDVDtJQUNGLEVBQUUsT0FBT2tCLEtBQUs7UUFDWmpCLFFBQVFELEtBQUssQ0FBQywyQkFBcUMsT0FBVitCLFdBQVUsTUFBSWI7UUFDdkQsT0FBTztZQUNMeUIsU0FBUztZQUNUM0MsT0FBT2tCLElBQUlXLE9BQU87UUFDcEI7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3N1cGFiYXNlQ2xpZW50LmpzPzVmMGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcblxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkw7XG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWTtcbmNvbnN0IHN1cGFiYXNlU2VydmljZUtleSA9IHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVk7XG5cbi8vIENyZWF0ZSBhIHN0YW5kYXJkIGNsaWVudCB3aXRoIHRoZSB1c2VyJ3Mgc2Vzc2lvblxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgYXV0aDoge1xuICAgIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICAgIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiB0cnVlLFxuICAgIHN0b3JhZ2VLZXk6ICdzYWRyYy1tZW1iZXJzaGlwLWF1dGgnLFxuICAgIHN0b3JhZ2U6IHtcbiAgICAgIGdldEl0ZW06IChrZXkpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uod2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSkpO1xuICAgICAgfSxcbiAgICAgIHNldEl0ZW06IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0sXG4gIH1cbn0pO1xuXG4vLyBDcmVhdGUgYSBzZXJ2aWNlIHJvbGUgY2xpZW50IGZvciBhZG1pbiBvcGVyYXRpb25zXG5leHBvcnQgY29uc3Qgc3VwYWJhc2VBZG1pbiA9IHN1cGFiYXNlU2VydmljZUtleSBcbiAgPyBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlU2VydmljZUtleSwge1xuICAgICAgYXV0aDoge1xuICAgICAgICBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSxcbiAgICAgICAgcGVyc2lzdFNlc3Npb246IGZhbHNlXG4gICAgICB9XG4gICAgfSlcbiAgOiBudWxsO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBjdXJyZW50IHNlc3Npb24gdG9rZW5cbmV4cG9ydCBjb25zdCBnZXRBdXRoVG9rZW4gPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKTtcbiAgICByZXR1cm4gZGF0YT8uc2Vzc2lvbj8uYWNjZXNzX3Rva2VuIHx8IG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBhdXRoIHRva2VuOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHVzZXIgaXMgbG9nZ2VkIGluXG5leHBvcnQgY29uc3QgaXNMb2dnZWRJbiA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpO1xuICAgIHJldHVybiAhIWRhdGE/LnNlc3Npb247XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgbG9naW4gc3RhdHVzOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiB1c2VyIGlzIGFkbWluXG5leHBvcnQgY29uc3QgaXNBZG1pbiA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKTtcbiAgICBpZiAoIXNlc3Npb25EYXRhPy5zZXNzaW9uKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2FkbWluX2xpc3QnKVxuICAgICAgLnNlbGVjdCgncm9sZScpXG4gICAgICAuZXEoJ2VtYWlsJywgc2Vzc2lvbkRhdGEuc2Vzc2lvbi51c2VyLmVtYWlsKVxuICAgICAgLm1heWJlU2luZ2xlKCk7XG4gICAgICBcbiAgICByZXR1cm4gISFkYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGFkbWluIHN0YXR1czonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBGb3JjZSBhIHNlc3Npb24gcmVmcmVzaFxuZXhwb3J0IGNvbnN0IHJlZnJlc2hTZXNzaW9uID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGgucmVmcmVzaFNlc3Npb24oKTtcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgIHJldHVybiBkYXRhPy5zZXNzaW9uO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlZnJlc2hpbmcgc2Vzc2lvbjonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBzYWZlbHkgdXNlIHRoZSBhZG1pbiBjbGllbnRcbmV4cG9ydCBjb25zdCB3aXRoU2VydmljZVJvbGUgPSBhc3luYyAob3BlcmF0aW9uKSA9PiB7XG4gIGlmICghc3VwYWJhc2VBZG1pbikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1NlcnZpY2Ugcm9sZSBrZXkgbm90IGF2YWlsYWJsZS4gRmFsbGluZyBiYWNrIHRvIHJlZ3VsYXIgY2xpZW50LicpO1xuICAgIHJldHVybiBvcGVyYXRpb24oc3VwYWJhc2UpO1xuICB9XG4gIFxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBvcGVyYXRpb24oc3VwYWJhc2VBZG1pbik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXNpbmcgc2VydmljZSByb2xlIGNsaWVudDonLCBlcnJvcik7XG4gICAgLy8gRmFsbGJhY2sgdG8gcmVndWxhciBjbGllbnQgaWYgc2VydmljZSByb2xlIGZhaWxzXG4gICAgcmV0dXJuIG9wZXJhdGlvbihzdXBhYmFzZSk7XG4gIH1cbn07XG5cbi8vIEFkZCBhIGN1c3RvbSBlcnJvciBoYW5kbGVyIGZvciBhdXRoIGVycm9yc1xuZXhwb3J0IGNvbnN0IGhhbmRsZUF1dGhFcnJvciA9IChlcnJvcikgPT4ge1xuICBpZiAoZXJyb3I/Lm5hbWUgPT09ICdBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcicpIHtcbiAgICBjb25zb2xlLmxvZygnU2Vzc2lvbiBtaXNzaW5nLCByZWRpcmVjdGluZyB0byBsb2dpbicpO1xuICAgIC8vIENsZWFyIGFueSBsb2NhbCBzdG9yYWdlIGl0ZW1zIHRoYXQgbWlnaHQgYmUgY2F1c2luZyBpc3N1ZXNcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdzYWRyYy1tZW1iZXJzaGlwLWF1dGgnKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdzdXBhYmFzZS5hdXRoLnRva2VuJyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlOyAvLyBJbmRpY2F0ZXMgdGhpcyB3YXMgYW4gYXV0aCBlcnJvciB0aGF0IHdhcyBoYW5kbGVkXG4gIH1cbiAgcmV0dXJuIGZhbHNlOyAvLyBOb3QgaGFuZGxlZFxufTtcblxuLy8gSGVscGVyIHRvIHNhZmVseSBnZXQgdGhlIGN1cnJlbnQgc2Vzc2lvblxuZXhwb3J0IGNvbnN0IHNhZmVHZXRTZXNzaW9uID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgaGFuZGxlQXV0aEVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7IHNlc3Npb246IG51bGwsIHVzZXI6IG51bGwgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgXG4gICAgICBzZXNzaW9uOiBkYXRhPy5zZXNzaW9uIHx8IG51bGwsXG4gICAgICB1c2VyOiBkYXRhPy5zZXNzaW9uPy51c2VyIHx8IG51bGxcbiAgICB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGdldHRpbmcgc2Vzc2lvbjonLCBlcnIpO1xuICAgIGhhbmRsZUF1dGhFcnJvcihlcnIpO1xuICAgIHJldHVybiB7IHNlc3Npb246IG51bGwsIHVzZXI6IG51bGwgfTtcbiAgfVxufTtcblxuLy8gRGVidWcgZnVuY3Rpb24gdG8gbG9nIGF1dGggc3RhdGUgYW5kIHNlc3Npb24gZGV0YWlsc1xuZXhwb3J0IGNvbnN0IGRlYnVnQXV0aFN0YXRlID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpO1xuICAgIGNvbnN0IHsgZGF0YTogdXNlckRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCc9PT09PT0gQVVUSCBERUJVRyBJTkZPID09PT09PScpO1xuICAgIGNvbnNvbGUubG9nKCdTZXNzaW9uIGV4aXN0czonLCAhIXNlc3Npb25EYXRhPy5zZXNzaW9uKTtcbiAgICBjb25zb2xlLmxvZygnSldUIGV4aXN0czonLCAhIXNlc3Npb25EYXRhPy5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4pO1xuICAgIGNvbnNvbGUubG9nKCdVc2VyIGV4aXN0czonLCAhIXVzZXJEYXRhPy51c2VyKTtcbiAgICBcbiAgICBpZiAodXNlckRhdGE/LnVzZXIpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdVc2VyIGVtYWlsOicsIHVzZXJEYXRhLnVzZXIuZW1haWwpO1xuICAgICAgY29uc29sZS5sb2coJ1VzZXIgSUQ6JywgdXNlckRhdGEudXNlci5pZCk7XG4gICAgfVxuICAgIFxuICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Nlc3Npb24gZXJyb3I6Jywgc2Vzc2lvbkVycm9yKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHVzZXJFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignVXNlciBlcnJvcjonLCB1c2VyRXJyb3IpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgaGFzU2Vzc2lvbjogISFzZXNzaW9uRGF0YT8uc2Vzc2lvbixcbiAgICAgIGhhc1VzZXI6ICEhdXNlckRhdGE/LnVzZXIsXG4gICAgICB1c2VyRW1haWw6IHVzZXJEYXRhPy51c2VyPy5lbWFpbCxcbiAgICAgIHVzZXJJZDogdXNlckRhdGE/LnVzZXI/LmlkLFxuICAgICAgc2Vzc2lvbkVycm9yLFxuICAgICAgdXNlckVycm9yXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZGVidWdBdXRoU3RhdGU6JywgZXJyKTtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzU2Vzc2lvbjogZmFsc2UsXG4gICAgICBoYXNVc2VyOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnIubWVzc2FnZVxuICAgIH07XG4gIH1cbn07XG5cbi8vIERlYnVnIGZ1bmN0aW9uIHRvIHRlc3QgUkxTIHBlcm1pc3Npb25zIG9uIHNwZWNpZmljIHRhYmxlc1xuZXhwb3J0IGNvbnN0IHRlc3RUYWJsZUFjY2VzcyA9IGFzeW5jICh0YWJsZU5hbWUsIGVtYWlsID0gbnVsbCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gc3VwYWJhc2UuZnJvbSh0YWJsZU5hbWUpLnNlbGVjdCgnKicpO1xuICAgIFxuICAgIC8vIElmIGVtYWlsIHByb3ZpZGVkLCB0cnkgdG8gZmlsdGVyIGJ5IGl0XG4gICAgaWYgKGVtYWlsKSB7XG4gICAgICBxdWVyeS5lcSgnZW1haWwnLCBlbWFpbCk7XG4gICAgfVxuICAgIFxuICAgIC8vIExpbWl0IHRvIGp1c3Qgb25lIHJvdyBmb3IgdGVzdGluZ1xuICAgIHF1ZXJ5LmxpbWl0KDEpO1xuICAgIFxuICAgIC8vIEV4ZWN1dGUgd2l0aCB0aW1lb3V0XG4gICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcihgUXVlcnkgdG8gJHt0YWJsZU5hbWV9IHRpbWVkIG91dGApKSwgNTAwMClcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICBxdWVyeSxcbiAgICAgIHRpbWVvdXRQcm9taXNlXG4gICAgXSk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYD09PT0gJHt0YWJsZU5hbWUudG9VcHBlckNhc2UoKX0gQUNDRVNTIFRFU1QgPT09PWApO1xuICAgIGNvbnNvbGUubG9nKCdRdWVyeSBzdWNjZXNzZnVsOicsICFlcnJvcik7XG4gICAgY29uc29sZS5sb2coJ0RhdGEgZm91bmQ6JywgISFkYXRhICYmIGRhdGEubGVuZ3RoID4gMCk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhY2Nlc3NpbmcgJHt0YWJsZU5hbWV9OmAsIGVycm9yKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6ICFlcnJvcixcbiAgICAgIGhhc0RhdGE6ICEhZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDAsXG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgZXJyb3I6IGVycm9yXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgdGVzdGluZyBhY2Nlc3MgdG8gJHt0YWJsZU5hbWV9OmAsIGVycik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVyci5tZXNzYWdlXG4gICAgfTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJzdXBhYmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJzdXBhYmFzZUFub25LZXkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsInN1cGFiYXNlU2VydmljZUtleSIsIlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkiLCJzdXBhYmFzZSIsImF1dGgiLCJwZXJzaXN0U2Vzc2lvbiIsImF1dG9SZWZyZXNoVG9rZW4iLCJkZXRlY3RTZXNzaW9uSW5VcmwiLCJzdG9yYWdlS2V5Iiwic3RvcmFnZSIsImdldEl0ZW0iLCJrZXkiLCJKU09OIiwicGFyc2UiLCJ3aW5kb3ciLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwidmFsdWUiLCJzdHJpbmdpZnkiLCJyZW1vdmVJdGVtIiwic3VwYWJhc2VBZG1pbiIsImdldEF1dGhUb2tlbiIsImRhdGEiLCJnZXRTZXNzaW9uIiwic2Vzc2lvbiIsImFjY2Vzc190b2tlbiIsImVycm9yIiwiY29uc29sZSIsImlzTG9nZ2VkSW4iLCJpc0FkbWluIiwic2Vzc2lvbkRhdGEiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJ1c2VyIiwiZW1haWwiLCJtYXliZVNpbmdsZSIsInJlZnJlc2hTZXNzaW9uIiwid2l0aFNlcnZpY2VSb2xlIiwib3BlcmF0aW9uIiwiaGFuZGxlQXV0aEVycm9yIiwibmFtZSIsImxvZyIsInNhZmVHZXRTZXNzaW9uIiwiZXJyIiwiZGVidWdBdXRoU3RhdGUiLCJ1c2VyRGF0YSIsInNlc3Npb25FcnJvciIsInVzZXJFcnJvciIsImdldFVzZXIiLCJpZCIsImhhc1Nlc3Npb24iLCJoYXNVc2VyIiwidXNlckVtYWlsIiwidXNlcklkIiwibWVzc2FnZSIsInRlc3RUYWJsZUFjY2VzcyIsInRhYmxlTmFtZSIsInF1ZXJ5IiwibGltaXQiLCJ0aW1lb3V0UHJvbWlzZSIsIlByb21pc2UiLCJfIiwicmVqZWN0Iiwic2V0VGltZW91dCIsIkVycm9yIiwicmFjZSIsInRvVXBwZXJDYXNlIiwibGVuZ3RoIiwic3VjY2VzcyIsImhhc0RhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/supabaseClient.js\n"));

/***/ })

});