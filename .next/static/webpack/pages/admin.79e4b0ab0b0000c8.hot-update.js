"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/admin",{

/***/ "./lib/pdfExportHelper.js":
/*!********************************!*\
  !*** ./lib/pdfExportHelper.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportMembersToPDF: function() { return /* binding */ exportMembersToPDF; }\n/* harmony export */ });\n/* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jspdf */ \"./node_modules/jspdf/dist/jspdf.es.min.js\");\n/* harmony import */ var jspdf_autotable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jspdf-autotable */ \"./node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.mjs\");\n// PDF Export Helper\n\n\n/**\n * Exports the given members array to a styled PDF file.\n * @param {Array} members - Array of member objects to export.\n * @param {String} exportType - Type of export ('full', 'competitions', 'aaga', or 'summary')\n */ function exportMembersToPDF(members) {\n    let exportType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"summary\";\n    try {\n        // Create new document with landscape orientation for better table display\n        const doc = new jspdf__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            orientation: \"landscape\",\n            unit: \"mm\",\n            format: \"a4\"\n        });\n        const pageWidth = doc.internal.pageSize.getWidth();\n        const pageHeight = doc.internal.pageSize.getHeight();\n        const margin = 16;\n        const currentDate = new Date().toLocaleDateString(\"en-GB\"); // Format as DD/MM/YYYY\n        // Add club logo/branding\n        addBranding(doc, pageWidth, margin);\n        // Set document properties\n        doc.setProperties({\n            title: \"SADRC Membership Export\",\n            subject: \"Membership Data\",\n            author: \"SADRC Admin System\",\n            creator: \"SADRC Membership App\"\n        });\n        // Add title and subtitle\n        let title = \"\";\n        let startY = margin + 30; // Adjusted for logo\n        // Configure columns and data based on export type\n        switch(exportType){\n            case \"active\":\n                title = \"Active Members\";\n                break;\n            case \"pending\":\n                title = \"Pending Members\";\n                break;\n            case \"expired\":\n                title = \"Expired Members\";\n                break;\n            case \"competitions\":\n                title = \"Club Competitions Participants\";\n                break;\n            case \"aaga\":\n                title = \"AaGA Challenge Participants\";\n                break;\n            case \"summary\":\n            default:\n                title = \"Membership Summary\";\n                break;\n        }\n        // Section title\n        doc.setFont(\"helvetica\", \"bold\");\n        doc.setFontSize(18);\n        doc.setTextColor(0, 0, 0);\n        doc.text(title, pageWidth / 2, startY, {\n            align: \"center\"\n        });\n        // Stats summary\n        startY += 10;\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.setFontSize(10);\n        // Make sure we have valid data before trying to filter\n        const safeMembers = Array.isArray(members) ? members : [];\n        const approvedCount = safeMembers.filter((m)=>m && m.status === \"approved\").length;\n        const pendingCount = safeMembers.filter((m)=>m && (!m.status || m.status === \"pending\")).length;\n        const paidCount = safeMembers.filter((m)=>m && m.payment_status === \"paid\").length;\n        const competitionsCount = safeMembers.filter((m)=>m && m.opt_in_competitions === true).length;\n        const aagaCount = safeMembers.filter((m)=>m && m.opt_in_aaga_challenge === true).length;\n        const activeCount = safeMembers.filter((m)=>m && m.membership_status === \"active\").length;\n        // Create a stats box\n        const statsBoxY = startY;\n        const statsBoxHeight = 20;\n        // Draw stats box background\n        doc.setFillColor(245, 245, 245);\n        doc.roundedRect(margin, statsBoxY, pageWidth - margin * 2, statsBoxHeight, 3, 3, \"F\");\n        // Add stats text\n        doc.setTextColor(80, 80, 80);\n        doc.text(\"Total Members: \".concat(safeMembers.length, \" | Approved: \").concat(approvedCount, \" | Pending: \").concat(pendingCount, \" | Paid: \").concat(paidCount), margin + 5, statsBoxY + 8);\n        doc.text(\"Active: \".concat(activeCount, \" | Competition Participants: \").concat(competitionsCount, \" | AaGA Challenge Participants: \").concat(aagaCount), margin + 5, statsBoxY + 16);\n        startY += statsBoxHeight + 10;\n        // Determine columns based on export type\n        let columns = [];\n        let rows = [];\n        // Configure columns and data based on export type\n        switch(exportType){\n            case \"active\":\n            case \"pending\":\n            case \"expired\":\n                columns = [\n                    {\n                        header: \"First Name\",\n                        dataKey: \"first_name\"\n                    },\n                    {\n                        header: \"Surname\",\n                        dataKey: \"surname\"\n                    },\n                    {\n                        header: \"Email\",\n                        dataKey: \"email\"\n                    },\n                    {\n                        header: \"Date of Birth\",\n                        dataKey: \"date_of_birth\"\n                    },\n                    {\n                        header: \"Status\",\n                        dataKey: \"status\"\n                    },\n                    {\n                        header: \"Payment\",\n                        dataKey: \"payment_status\"\n                    },\n                    {\n                        header: \"EA Number\",\n                        dataKey: \"ea_number\"\n                    },\n                    {\n                        header: \"Expiry Date\",\n                        dataKey: \"membership_expiry\"\n                    }\n                ];\n                rows = safeMembers.map((m)=>({\n                        first_name: m.first_name || \"\",\n                        surname: m.surname || \"\",\n                        email: m.email || \"\",\n                        date_of_birth: formatDate(m.date_of_birth),\n                        status: formatStatus(m.status || \"pending\"),\n                        payment_status: m.payment_status === \"paid\" ? \"Paid\" : \"Unpaid\",\n                        ea_number: m.ea_number || \"Not registered\",\n                        membership_expiry: formatDate(m.membership_expiry)\n                    }));\n                break;\n            case \"competitions\":\n                const competitionMembers = safeMembers.filter((m)=>m && m.opt_in_competitions);\n                columns = [\n                    {\n                        header: \"First Name\",\n                        dataKey: \"first_name\"\n                    },\n                    {\n                        header: \"Surname\",\n                        dataKey: \"surname\"\n                    },\n                    {\n                        header: \"Email\",\n                        dataKey: \"email\"\n                    },\n                    {\n                        header: \"Date of Birth\",\n                        dataKey: \"date_of_birth\"\n                    },\n                    {\n                        header: \"Membership Status\",\n                        dataKey: \"membership_status\"\n                    },\n                    {\n                        header: \"Payment Status\",\n                        dataKey: \"payment_status\"\n                    },\n                    {\n                        header: \"EA Number\",\n                        dataKey: \"ea_number\"\n                    }\n                ];\n                rows = competitionMembers.map((m)=>({\n                        first_name: m.first_name || \"\",\n                        surname: m.surname || \"\",\n                        email: m.email || \"\",\n                        date_of_birth: formatDate(m.date_of_birth),\n                        membership_status: formatStatus(m.membership_status || \"pending\"),\n                        payment_status: m.payment_status === \"paid\" ? \"Paid\" : \"Unpaid\",\n                        ea_number: m.ea_number || \"Not registered\"\n                    }));\n                break;\n            case \"aaga\":\n                const aagaMembers = safeMembers.filter((m)=>m && m.opt_in_aaga_challenge);\n                columns = [\n                    {\n                        header: \"First Name\",\n                        dataKey: \"first_name\"\n                    },\n                    {\n                        header: \"Surname\",\n                        dataKey: \"surname\"\n                    },\n                    {\n                        header: \"Email\",\n                        dataKey: \"email\"\n                    },\n                    {\n                        header: \"Date of Birth\",\n                        dataKey: \"date_of_birth\"\n                    },\n                    {\n                        header: \"Membership Status\",\n                        dataKey: \"membership_status\"\n                    },\n                    {\n                        header: \"Payment Status\",\n                        dataKey: \"payment_status\"\n                    }\n                ];\n                rows = aagaMembers.map((m)=>({\n                        first_name: m.first_name || \"\",\n                        surname: m.surname || \"\",\n                        email: m.email || \"\",\n                        date_of_birth: formatDate(m.date_of_birth),\n                        membership_status: formatStatus(m.membership_status || \"pending\"),\n                        payment_status: m.payment_status === \"paid\" ? \"Paid\" : \"Unpaid\"\n                    }));\n                break;\n            case \"summary\":\n            default:\n                columns = [\n                    {\n                        header: \"First Name\",\n                        dataKey: \"first_name\"\n                    },\n                    {\n                        header: \"Surname\",\n                        dataKey: \"surname\"\n                    },\n                    {\n                        header: \"Email\",\n                        dataKey: \"email\"\n                    },\n                    {\n                        header: \"Status\",\n                        dataKey: \"status\"\n                    },\n                    {\n                        header: \"Payment\",\n                        dataKey: \"payment_status\"\n                    }\n                ];\n                rows = safeMembers.map((m)=>({\n                        first_name: m.first_name || \"\",\n                        surname: m.surname || \"\",\n                        email: m.email || \"\",\n                        status: formatStatus(m.status || \"pending\"),\n                        payment_status: m.payment_status === \"paid\" ? \"Paid\" : \"Unpaid\"\n                    }));\n                break;\n        }\n        // Table\n        (0,jspdf_autotable__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(doc, {\n            head: [\n                columns.map((col)=>col.header)\n            ],\n            body: rows.map((row)=>columns.map((col)=>row[col.dataKey])),\n            startY: startY,\n            margin: {\n                left: margin,\n                right: margin\n            },\n            styles: {\n                fontSize: 10,\n                cellPadding: 4,\n                valign: \"middle\",\n                overflow: \"linebreak\",\n                textColor: [\n                    30,\n                    30,\n                    30\n                ],\n                halign: \"left\",\n                minCellHeight: 10,\n                lineWidth: 0.1\n            },\n            headStyles: {\n                fillColor: [\n                    255,\n                    102,\n                    0\n                ],\n                textColor: [\n                    255,\n                    255,\n                    255\n                ],\n                fontStyle: \"bold\",\n                fontSize: 11,\n                halign: \"left\",\n                cellPadding: 5\n            },\n            alternateRowStyles: {\n                fillColor: [\n                    245,\n                    245,\n                    245\n                ]\n            },\n            columnStyles: getColumnStyles(columns),\n            didDrawPage: (data)=>{\n                // Add header to each page\n                if (data.pageNumber > 1) {\n                    addBranding(doc, pageWidth, margin);\n                }\n                // Add footer to each page\n                addFooter(doc, pageWidth, pageHeight, data.pageNumber, doc.getNumberOfPages(), margin);\n            }\n        });\n        // Save the PDF\n        const filename = \"sadrc_members_\".concat(exportType, \"_\").concat(new Date().toISOString().split(\"T\")[0], \".pdf\");\n        doc.save(filename);\n        return filename;\n    } catch (error) {\n        console.error(\"PDF Export Error Details:\", {\n            message: error.message || \"Unknown error\",\n            stack: error.stack || \"No stack trace\",\n            exportType: exportType || \"unknown\"\n        });\n        throw error; // Re-throw to allow the calling function to handle it\n    }\n}\n/**\n * Adds branding elements to the PDF\n */ function addBranding(doc, pageWidth, margin) {\n    try {\n        // Header background\n        doc.setFillColor(255, 102, 0);\n        doc.rect(0, 0, pageWidth, margin + 10, \"F\");\n        // Title\n        doc.setFontSize(24);\n        doc.setTextColor(255, 255, 255);\n        doc.setFont(\"helvetica\", \"bold\");\n        doc.text(\"SADRC Membership\", pageWidth / 2, margin, {\n            align: \"center\"\n        });\n        // Date line\n        doc.setDrawColor(255, 255, 255);\n        doc.setLineWidth(0.5);\n        doc.line(margin, margin + 4, pageWidth - margin, margin + 4);\n        // Export date\n        doc.setFontSize(11);\n        doc.setTextColor(255, 255, 255);\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.text(\"Export Date: \".concat(new Date().toLocaleDateString(\"en-GB\")), pageWidth / 2, margin + 10, {\n            align: \"center\"\n        });\n    } catch (error) {\n        console.error(\"Error in addBranding:\", error);\n    // Continue execution even if branding fails\n    }\n}\n/**\n * Adds a footer to each page\n */ function addFooter(doc, pageWidth, pageHeight, pageNumber, totalPages, margin) {\n    try {\n        // Footer line\n        doc.setDrawColor(200, 200, 200);\n        doc.setLineWidth(0.5);\n        doc.line(margin, pageHeight - 15, pageWidth - margin, pageHeight - 15);\n        // Page numbers and confidentiality notice\n        doc.setFontSize(8);\n        doc.setTextColor(120, 120, 120);\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.text(\"Skegness & District Running Club - Confidential - Page \".concat(pageNumber, \" of \").concat(totalPages), pageWidth / 2, pageHeight - 8, {\n            align: \"center\"\n        });\n    } catch (error) {\n        console.error(\"Error in addFooter:\", error);\n    // Continue execution even if footer fails\n    }\n}\n/**\n * Returns appropriate column styles based on the columns array\n */ function getColumnStyles(columns) {\n    try {\n        const styles = {};\n        // Set width for each column type\n        columns.forEach((col, index)=>{\n            switch(col.dataKey){\n                case \"first_name\":\n                case \"surname\":\n                    styles[index] = {\n                        cellWidth: 25\n                    };\n                    break;\n                case \"email\":\n                    styles[index] = {\n                        cellWidth: 50\n                    };\n                    break;\n                case \"date_of_birth\":\n                case \"membership_expiry\":\n                    styles[index] = {\n                        cellWidth: 25,\n                        halign: \"center\"\n                    };\n                    break;\n                case \"status\":\n                case \"membership_status\":\n                case \"payment_status\":\n                    styles[index] = {\n                        cellWidth: 25,\n                        halign: \"center\"\n                    };\n                    break;\n                case \"ea_number\":\n                    styles[index] = {\n                        cellWidth: 30,\n                        halign: \"center\"\n                    };\n                    break;\n                default:\n                    styles[index] = {\n                        cellWidth: \"auto\"\n                    };\n            }\n        });\n        return styles;\n    } catch (error) {\n        console.error(\"Error in getColumnStyles:\", error);\n        return {}; // Return empty object as fallback\n    }\n}\n/**\n * Formats a date string to DD/MM/YYYY\n */ function formatDate(dateString) {\n    if (!dateString) return \"Not set\";\n    try {\n        const date = new Date(dateString);\n        if (isNaN(date.getTime())) return \"Invalid date\";\n        return date.toLocaleDateString(\"en-GB\");\n    } catch (e) {\n        console.error(\"Date formatting error:\", e);\n        return dateString || \"Not set\";\n    }\n}\n/**\n * Formats status with proper capitalization\n */ function formatStatus(status) {\n    if (!status) return \"Pending\";\n    try {\n        return status.charAt(0).toUpperCase() + status.slice(1);\n    } catch (e) {\n        console.error(\"Status formatting error:\", e);\n        return status || \"Pending\";\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q3ZELEVBQUUsT0FBT0gsR0FBRztRQUNWZixRQUFRRCxLQUFLLENBQUMsNEJBQTRCZ0I7UUFDMUMsT0FBTzVFLFVBQVU7SUFDbkI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvcGRmRXhwb3J0SGVscGVyLmpzP2MwODEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUERGIEV4cG9ydCBIZWxwZXJcbmltcG9ydCBqc1BERiBmcm9tICdqc3BkZic7XG5pbXBvcnQgYXV0b1RhYmxlIGZyb20gJ2pzcGRmLWF1dG90YWJsZSc7XG5cbi8qKlxuICogRXhwb3J0cyB0aGUgZ2l2ZW4gbWVtYmVycyBhcnJheSB0byBhIHN0eWxlZCBQREYgZmlsZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG1lbWJlcnMgLSBBcnJheSBvZiBtZW1iZXIgb2JqZWN0cyB0byBleHBvcnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwb3J0VHlwZSAtIFR5cGUgb2YgZXhwb3J0ICgnZnVsbCcsICdjb21wZXRpdGlvbnMnLCAnYWFnYScsIG9yICdzdW1tYXJ5JylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cG9ydE1lbWJlcnNUb1BERihtZW1iZXJzLCBleHBvcnRUeXBlID0gJ3N1bW1hcnknKSB7XG4gIHRyeSB7XG4gICAgLy8gQ3JlYXRlIG5ldyBkb2N1bWVudCB3aXRoIGxhbmRzY2FwZSBvcmllbnRhdGlvbiBmb3IgYmV0dGVyIHRhYmxlIGRpc3BsYXlcbiAgICBjb25zdCBkb2MgPSBuZXcganNQREYoeyBvcmllbnRhdGlvbjogJ2xhbmRzY2FwZScsIHVuaXQ6ICdtbScsIGZvcm1hdDogJ2E0JyB9KTtcbiAgICBjb25zdCBwYWdlV2lkdGggPSBkb2MuaW50ZXJuYWwucGFnZVNpemUuZ2V0V2lkdGgoKTtcbiAgICBjb25zdCBwYWdlSGVpZ2h0ID0gZG9jLmludGVybmFsLnBhZ2VTaXplLmdldEhlaWdodCgpO1xuICAgIGNvbnN0IG1hcmdpbiA9IDE2O1xuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLUdCJyk7IC8vIEZvcm1hdCBhcyBERC9NTS9ZWVlZXG4gICAgXG4gICAgLy8gQWRkIGNsdWIgbG9nby9icmFuZGluZ1xuICAgIGFkZEJyYW5kaW5nKGRvYywgcGFnZVdpZHRoLCBtYXJnaW4pO1xuXG4gICAgLy8gU2V0IGRvY3VtZW50IHByb3BlcnRpZXNcbiAgICBkb2Muc2V0UHJvcGVydGllcyh7XG4gICAgICB0aXRsZTogJ1NBRFJDIE1lbWJlcnNoaXAgRXhwb3J0JyxcbiAgICAgIHN1YmplY3Q6ICdNZW1iZXJzaGlwIERhdGEnLFxuICAgICAgYXV0aG9yOiAnU0FEUkMgQWRtaW4gU3lzdGVtJyxcbiAgICAgIGNyZWF0b3I6ICdTQURSQyBNZW1iZXJzaGlwIEFwcCdcbiAgICB9KTtcblxuICAgIC8vIEFkZCB0aXRsZSBhbmQgc3VidGl0bGVcbiAgICBsZXQgdGl0bGUgPSAnJztcbiAgICBsZXQgc3RhcnRZID0gbWFyZ2luICsgMzA7IC8vIEFkanVzdGVkIGZvciBsb2dvXG5cbiAgICAvLyBDb25maWd1cmUgY29sdW1ucyBhbmQgZGF0YSBiYXNlZCBvbiBleHBvcnQgdHlwZVxuICAgIHN3aXRjaCAoZXhwb3J0VHlwZSkge1xuICAgICAgY2FzZSAnYWN0aXZlJzpcbiAgICAgICAgdGl0bGUgPSAnQWN0aXZlIE1lbWJlcnMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3BlbmRpbmcnOlxuICAgICAgICB0aXRsZSA9ICdQZW5kaW5nIE1lbWJlcnMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2V4cGlyZWQnOlxuICAgICAgICB0aXRsZSA9ICdFeHBpcmVkIE1lbWJlcnMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NvbXBldGl0aW9ucyc6XG4gICAgICAgIHRpdGxlID0gJ0NsdWIgQ29tcGV0aXRpb25zIFBhcnRpY2lwYW50cyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYWFnYSc6XG4gICAgICAgIHRpdGxlID0gJ0FhR0EgQ2hhbGxlbmdlIFBhcnRpY2lwYW50cyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aXRsZSA9ICdNZW1iZXJzaGlwIFN1bW1hcnknO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBTZWN0aW9uIHRpdGxlXG4gICAgZG9jLnNldEZvbnQoJ2hlbHZldGljYScsICdib2xkJyk7XG4gICAgZG9jLnNldEZvbnRTaXplKDE4KTtcbiAgICBkb2Muc2V0VGV4dENvbG9yKDAsIDAsIDApO1xuICAgIGRvYy50ZXh0KHRpdGxlLCBwYWdlV2lkdGggLyAyLCBzdGFydFksIHsgYWxpZ246ICdjZW50ZXInIH0pO1xuXG4gICAgLy8gU3RhdHMgc3VtbWFyeVxuICAgIHN0YXJ0WSArPSAxMDtcbiAgICBkb2Muc2V0Rm9udCgnaGVsdmV0aWNhJywgJ25vcm1hbCcpO1xuICAgIGRvYy5zZXRGb250U2l6ZSgxMCk7XG4gICAgXG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgdmFsaWQgZGF0YSBiZWZvcmUgdHJ5aW5nIHRvIGZpbHRlclxuICAgIGNvbnN0IHNhZmVNZW1iZXJzID0gQXJyYXkuaXNBcnJheShtZW1iZXJzKSA/IG1lbWJlcnMgOiBbXTtcbiAgICBcbiAgICBjb25zdCBhcHByb3ZlZENvdW50ID0gc2FmZU1lbWJlcnMuZmlsdGVyKG0gPT4gbSAmJiBtLnN0YXR1cyA9PT0gJ2FwcHJvdmVkJykubGVuZ3RoO1xuICAgIGNvbnN0IHBlbmRpbmdDb3VudCA9IHNhZmVNZW1iZXJzLmZpbHRlcihtID0+IG0gJiYgKCFtLnN0YXR1cyB8fCBtLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSkubGVuZ3RoO1xuICAgIGNvbnN0IHBhaWRDb3VudCA9IHNhZmVNZW1iZXJzLmZpbHRlcihtID0+IG0gJiYgbS5wYXltZW50X3N0YXR1cyA9PT0gJ3BhaWQnKS5sZW5ndGg7XG4gICAgY29uc3QgY29tcGV0aXRpb25zQ291bnQgPSBzYWZlTWVtYmVycy5maWx0ZXIobSA9PiBtICYmIG0ub3B0X2luX2NvbXBldGl0aW9ucyA9PT0gdHJ1ZSkubGVuZ3RoO1xuICAgIGNvbnN0IGFhZ2FDb3VudCA9IHNhZmVNZW1iZXJzLmZpbHRlcihtID0+IG0gJiYgbS5vcHRfaW5fYWFnYV9jaGFsbGVuZ2UgPT09IHRydWUpLmxlbmd0aDtcbiAgICBjb25zdCBhY3RpdmVDb3VudCA9IHNhZmVNZW1iZXJzLmZpbHRlcihtID0+IG0gJiYgbS5tZW1iZXJzaGlwX3N0YXR1cyA9PT0gJ2FjdGl2ZScpLmxlbmd0aDtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBzdGF0cyBib3hcbiAgICBjb25zdCBzdGF0c0JveFkgPSBzdGFydFk7XG4gICAgY29uc3Qgc3RhdHNCb3hIZWlnaHQgPSAyMDtcbiAgICBcbiAgICAvLyBEcmF3IHN0YXRzIGJveCBiYWNrZ3JvdW5kXG4gICAgZG9jLnNldEZpbGxDb2xvcigyNDUsIDI0NSwgMjQ1KTtcbiAgICBkb2Mucm91bmRlZFJlY3QobWFyZ2luLCBzdGF0c0JveFksIHBhZ2VXaWR0aCAtIChtYXJnaW4gKiAyKSwgc3RhdHNCb3hIZWlnaHQsIDMsIDMsICdGJyk7XG4gICAgXG4gICAgLy8gQWRkIHN0YXRzIHRleHRcbiAgICBkb2Muc2V0VGV4dENvbG9yKDgwLCA4MCwgODApO1xuICAgIGRvYy50ZXh0KGBUb3RhbCBNZW1iZXJzOiAke3NhZmVNZW1iZXJzLmxlbmd0aH0gfCBBcHByb3ZlZDogJHthcHByb3ZlZENvdW50fSB8IFBlbmRpbmc6ICR7cGVuZGluZ0NvdW50fSB8IFBhaWQ6ICR7cGFpZENvdW50fWAsXG4gICAgICBtYXJnaW4gKyA1LCBzdGF0c0JveFkgKyA4KTtcbiAgICBkb2MudGV4dChgQWN0aXZlOiAke2FjdGl2ZUNvdW50fSB8IENvbXBldGl0aW9uIFBhcnRpY2lwYW50czogJHtjb21wZXRpdGlvbnNDb3VudH0gfCBBYUdBIENoYWxsZW5nZSBQYXJ0aWNpcGFudHM6ICR7YWFnYUNvdW50fWAsXG4gICAgICBtYXJnaW4gKyA1LCBzdGF0c0JveFkgKyAxNik7XG5cbiAgICBzdGFydFkgKz0gc3RhdHNCb3hIZWlnaHQgKyAxMDtcblxuICAgIC8vIERldGVybWluZSBjb2x1bW5zIGJhc2VkIG9uIGV4cG9ydCB0eXBlXG4gICAgbGV0IGNvbHVtbnMgPSBbXTtcbiAgICBsZXQgcm93cyA9IFtdO1xuXG4gICAgLy8gQ29uZmlndXJlIGNvbHVtbnMgYW5kIGRhdGEgYmFzZWQgb24gZXhwb3J0IHR5cGVcbiAgICBzd2l0Y2ggKGV4cG9ydFR5cGUpIHtcbiAgICAgIGNhc2UgJ2FjdGl2ZSc6XG4gICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgIGNhc2UgJ2V4cGlyZWQnOlxuICAgICAgICBjb2x1bW5zID0gW1xuICAgICAgICAgIHsgaGVhZGVyOiAnRmlyc3QgTmFtZScsIGRhdGFLZXk6ICdmaXJzdF9uYW1lJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnU3VybmFtZScsIGRhdGFLZXk6ICdzdXJuYW1lJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnRW1haWwnLCBkYXRhS2V5OiAnZW1haWwnIH0sXG4gICAgICAgICAgeyBoZWFkZXI6ICdEYXRlIG9mIEJpcnRoJywgZGF0YUtleTogJ2RhdGVfb2ZfYmlydGgnIH0sXG4gICAgICAgICAgeyBoZWFkZXI6ICdTdGF0dXMnLCBkYXRhS2V5OiAnc3RhdHVzJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnUGF5bWVudCcsIGRhdGFLZXk6ICdwYXltZW50X3N0YXR1cycgfSxcbiAgICAgICAgICB7IGhlYWRlcjogJ0VBIE51bWJlcicsIGRhdGFLZXk6ICdlYV9udW1iZXInIH0sXG4gICAgICAgICAgeyBoZWFkZXI6ICdFeHBpcnkgRGF0ZScsIGRhdGFLZXk6ICdtZW1iZXJzaGlwX2V4cGlyeScgfVxuICAgICAgICBdO1xuICAgICAgICByb3dzID0gc2FmZU1lbWJlcnMubWFwKG0gPT4gKHtcbiAgICAgICAgICBmaXJzdF9uYW1lOiBtLmZpcnN0X25hbWUgfHwgJycsXG4gICAgICAgICAgc3VybmFtZTogbS5zdXJuYW1lIHx8ICcnLFxuICAgICAgICAgIGVtYWlsOiBtLmVtYWlsIHx8ICcnLFxuICAgICAgICAgIGRhdGVfb2ZfYmlydGg6IGZvcm1hdERhdGUobS5kYXRlX29mX2JpcnRoKSxcbiAgICAgICAgICBzdGF0dXM6IGZvcm1hdFN0YXR1cyhtLnN0YXR1cyB8fCAncGVuZGluZycpLFxuICAgICAgICAgIHBheW1lbnRfc3RhdHVzOiBtLnBheW1lbnRfc3RhdHVzID09PSAncGFpZCcgPyAnUGFpZCcgOiAnVW5wYWlkJyxcbiAgICAgICAgICBlYV9udW1iZXI6IG0uZWFfbnVtYmVyIHx8ICdOb3QgcmVnaXN0ZXJlZCcsXG4gICAgICAgICAgbWVtYmVyc2hpcF9leHBpcnk6IGZvcm1hdERhdGUobS5tZW1iZXJzaGlwX2V4cGlyeSlcbiAgICAgICAgfSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NvbXBldGl0aW9ucyc6XG4gICAgICAgIGNvbnN0IGNvbXBldGl0aW9uTWVtYmVycyA9IHNhZmVNZW1iZXJzLmZpbHRlcihtID0+IG0gJiYgbS5vcHRfaW5fY29tcGV0aXRpb25zKTtcbiAgICAgICAgY29sdW1ucyA9IFtcbiAgICAgICAgICB7IGhlYWRlcjogJ0ZpcnN0IE5hbWUnLCBkYXRhS2V5OiAnZmlyc3RfbmFtZScgfSxcbiAgICAgICAgICB7IGhlYWRlcjogJ1N1cm5hbWUnLCBkYXRhS2V5OiAnc3VybmFtZScgfSxcbiAgICAgICAgICB7IGhlYWRlcjogJ0VtYWlsJywgZGF0YUtleTogJ2VtYWlsJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnRGF0ZSBvZiBCaXJ0aCcsIGRhdGFLZXk6ICdkYXRlX29mX2JpcnRoJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnTWVtYmVyc2hpcCBTdGF0dXMnLCBkYXRhS2V5OiAnbWVtYmVyc2hpcF9zdGF0dXMnIH0sXG4gICAgICAgICAgeyBoZWFkZXI6ICdQYXltZW50IFN0YXR1cycsIGRhdGFLZXk6ICdwYXltZW50X3N0YXR1cycgfSxcbiAgICAgICAgICB7IGhlYWRlcjogJ0VBIE51bWJlcicsIGRhdGFLZXk6ICdlYV9udW1iZXInIH1cbiAgICAgICAgXTtcbiAgICAgICAgcm93cyA9IGNvbXBldGl0aW9uTWVtYmVycy5tYXAobSA9PiAoe1xuICAgICAgICAgIGZpcnN0X25hbWU6IG0uZmlyc3RfbmFtZSB8fCAnJyxcbiAgICAgICAgICBzdXJuYW1lOiBtLnN1cm5hbWUgfHwgJycsXG4gICAgICAgICAgZW1haWw6IG0uZW1haWwgfHwgJycsXG4gICAgICAgICAgZGF0ZV9vZl9iaXJ0aDogZm9ybWF0RGF0ZShtLmRhdGVfb2ZfYmlydGgpLFxuICAgICAgICAgIG1lbWJlcnNoaXBfc3RhdHVzOiBmb3JtYXRTdGF0dXMobS5tZW1iZXJzaGlwX3N0YXR1cyB8fCAncGVuZGluZycpLFxuICAgICAgICAgIHBheW1lbnRfc3RhdHVzOiBtLnBheW1lbnRfc3RhdHVzID09PSAncGFpZCcgPyAnUGFpZCcgOiAnVW5wYWlkJyxcbiAgICAgICAgICBlYV9udW1iZXI6IG0uZWFfbnVtYmVyIHx8ICdOb3QgcmVnaXN0ZXJlZCdcbiAgICAgICAgfSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FhZ2EnOlxuICAgICAgICBjb25zdCBhYWdhTWVtYmVycyA9IHNhZmVNZW1iZXJzLmZpbHRlcihtID0+IG0gJiYgbS5vcHRfaW5fYWFnYV9jaGFsbGVuZ2UpO1xuICAgICAgICBjb2x1bW5zID0gW1xuICAgICAgICAgIHsgaGVhZGVyOiAnRmlyc3QgTmFtZScsIGRhdGFLZXk6ICdmaXJzdF9uYW1lJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnU3VybmFtZScsIGRhdGFLZXk6ICdzdXJuYW1lJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnRW1haWwnLCBkYXRhS2V5OiAnZW1haWwnIH0sXG4gICAgICAgICAgeyBoZWFkZXI6ICdEYXRlIG9mIEJpcnRoJywgZGF0YUtleTogJ2RhdGVfb2ZfYmlydGgnIH0sXG4gICAgICAgICAgeyBoZWFkZXI6ICdNZW1iZXJzaGlwIFN0YXR1cycsIGRhdGFLZXk6ICdtZW1iZXJzaGlwX3N0YXR1cycgfSxcbiAgICAgICAgICB7IGhlYWRlcjogJ1BheW1lbnQgU3RhdHVzJywgZGF0YUtleTogJ3BheW1lbnRfc3RhdHVzJyB9XG4gICAgICAgIF07XG4gICAgICAgIHJvd3MgPSBhYWdhTWVtYmVycy5tYXAobSA9PiAoe1xuICAgICAgICAgIGZpcnN0X25hbWU6IG0uZmlyc3RfbmFtZSB8fCAnJyxcbiAgICAgICAgICBzdXJuYW1lOiBtLnN1cm5hbWUgfHwgJycsXG4gICAgICAgICAgZW1haWw6IG0uZW1haWwgfHwgJycsXG4gICAgICAgICAgZGF0ZV9vZl9iaXJ0aDogZm9ybWF0RGF0ZShtLmRhdGVfb2ZfYmlydGgpLFxuICAgICAgICAgIG1lbWJlcnNoaXBfc3RhdHVzOiBmb3JtYXRTdGF0dXMobS5tZW1iZXJzaGlwX3N0YXR1cyB8fCAncGVuZGluZycpLFxuICAgICAgICAgIHBheW1lbnRfc3RhdHVzOiBtLnBheW1lbnRfc3RhdHVzID09PSAncGFpZCcgPyAnUGFpZCcgOiAnVW5wYWlkJ1xuICAgICAgICB9KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb2x1bW5zID0gW1xuICAgICAgICAgIHsgaGVhZGVyOiAnRmlyc3QgTmFtZScsIGRhdGFLZXk6ICdmaXJzdF9uYW1lJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnU3VybmFtZScsIGRhdGFLZXk6ICdzdXJuYW1lJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnRW1haWwnLCBkYXRhS2V5OiAnZW1haWwnIH0sXG4gICAgICAgICAgeyBoZWFkZXI6ICdTdGF0dXMnLCBkYXRhS2V5OiAnc3RhdHVzJyB9LFxuICAgICAgICAgIHsgaGVhZGVyOiAnUGF5bWVudCcsIGRhdGFLZXk6ICdwYXltZW50X3N0YXR1cycgfVxuICAgICAgICBdO1xuICAgICAgICByb3dzID0gc2FmZU1lbWJlcnMubWFwKG0gPT4gKHtcbiAgICAgICAgICBmaXJzdF9uYW1lOiBtLmZpcnN0X25hbWUgfHwgJycsXG4gICAgICAgICAgc3VybmFtZTogbS5zdXJuYW1lIHx8ICcnLFxuICAgICAgICAgIGVtYWlsOiBtLmVtYWlsIHx8ICcnLFxuICAgICAgICAgIHN0YXR1czogZm9ybWF0U3RhdHVzKG0uc3RhdHVzIHx8ICdwZW5kaW5nJyksXG4gICAgICAgICAgcGF5bWVudF9zdGF0dXM6IG0ucGF5bWVudF9zdGF0dXMgPT09ICdwYWlkJyA/ICdQYWlkJyA6ICdVbnBhaWQnXG4gICAgICAgIH0pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gVGFibGVcbiAgICBhdXRvVGFibGUoZG9jLCB7XG4gICAgICBoZWFkOiBbY29sdW1ucy5tYXAoY29sID0+IGNvbC5oZWFkZXIpXSxcbiAgICAgIGJvZHk6IHJvd3MubWFwKHJvdyA9PiBjb2x1bW5zLm1hcChjb2wgPT4gcm93W2NvbC5kYXRhS2V5XSkpLFxuICAgICAgc3RhcnRZOiBzdGFydFksXG4gICAgICBtYXJnaW46IHsgbGVmdDogbWFyZ2luLCByaWdodDogbWFyZ2luIH0sXG4gICAgICBzdHlsZXM6IHtcbiAgICAgICAgZm9udFNpemU6IDEwLFxuICAgICAgICBjZWxsUGFkZGluZzogNCxcbiAgICAgICAgdmFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgb3ZlcmZsb3c6ICdsaW5lYnJlYWsnLFxuICAgICAgICB0ZXh0Q29sb3I6IFszMCwgMzAsIDMwXSxcbiAgICAgICAgaGFsaWduOiAnbGVmdCcsXG4gICAgICAgIG1pbkNlbGxIZWlnaHQ6IDEwLFxuICAgICAgICBsaW5lV2lkdGg6IDAuMSxcbiAgICAgIH0sXG4gICAgICBoZWFkU3R5bGVzOiB7XG4gICAgICAgIGZpbGxDb2xvcjogWzI1NSwgMTAyLCAwXSxcbiAgICAgICAgdGV4dENvbG9yOiBbMjU1LCAyNTUsIDI1NV0sXG4gICAgICAgIGZvbnRTdHlsZTogJ2JvbGQnLFxuICAgICAgICBmb250U2l6ZTogMTEsXG4gICAgICAgIGhhbGlnbjogJ2xlZnQnLFxuICAgICAgICBjZWxsUGFkZGluZzogNSxcbiAgICAgIH0sXG4gICAgICBhbHRlcm5hdGVSb3dTdHlsZXM6IHsgZmlsbENvbG9yOiBbMjQ1LCAyNDUsIDI0NV0gfSxcbiAgICAgIGNvbHVtblN0eWxlczogZ2V0Q29sdW1uU3R5bGVzKGNvbHVtbnMpLFxuICAgICAgZGlkRHJhd1BhZ2U6IChkYXRhKSA9PiB7XG4gICAgICAgIC8vIEFkZCBoZWFkZXIgdG8gZWFjaCBwYWdlXG4gICAgICAgIGlmIChkYXRhLnBhZ2VOdW1iZXIgPiAxKSB7XG4gICAgICAgICAgYWRkQnJhbmRpbmcoZG9jLCBwYWdlV2lkdGgsIG1hcmdpbik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBmb290ZXIgdG8gZWFjaCBwYWdlXG4gICAgICAgIGFkZEZvb3Rlcihkb2MsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgZGF0YS5wYWdlTnVtYmVyLCBkb2MuZ2V0TnVtYmVyT2ZQYWdlcygpLCBtYXJnaW4pO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIFNhdmUgdGhlIFBERlxuICAgIGNvbnN0IGZpbGVuYW1lID0gYHNhZHJjX21lbWJlcnNfJHtleHBvcnRUeXBlfV8ke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdfS5wZGZgO1xuICAgIGRvYy5zYXZlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZmlsZW5hbWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignUERGIEV4cG9ydCBFcnJvciBEZXRhaWxzOicsIHsgXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJyxcbiAgICAgIHN0YWNrOiBlcnJvci5zdGFjayB8fCAnTm8gc3RhY2sgdHJhY2UnLFxuICAgICAgZXhwb3J0VHlwZTogZXhwb3J0VHlwZSB8fCAndW5rbm93bidcbiAgICB9KTtcbiAgICB0aHJvdyBlcnJvcjsgLy8gUmUtdGhyb3cgdG8gYWxsb3cgdGhlIGNhbGxpbmcgZnVuY3Rpb24gdG8gaGFuZGxlIGl0XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGJyYW5kaW5nIGVsZW1lbnRzIHRvIHRoZSBQREZcbiAqL1xuZnVuY3Rpb24gYWRkQnJhbmRpbmcoZG9jLCBwYWdlV2lkdGgsIG1hcmdpbikge1xuICB0cnkge1xuICAgIC8vIEhlYWRlciBiYWNrZ3JvdW5kXG4gICAgZG9jLnNldEZpbGxDb2xvcigyNTUsIDEwMiwgMCk7XG4gICAgZG9jLnJlY3QoMCwgMCwgcGFnZVdpZHRoLCBtYXJnaW4gKyAxMCwgJ0YnKTtcbiAgICBcbiAgICAvLyBUaXRsZVxuICAgIGRvYy5zZXRGb250U2l6ZSgyNCk7XG4gICAgZG9jLnNldFRleHRDb2xvcigyNTUsIDI1NSwgMjU1KTtcbiAgICBkb2Muc2V0Rm9udCgnaGVsdmV0aWNhJywgJ2JvbGQnKTtcbiAgICBkb2MudGV4dCgnU0FEUkMgTWVtYmVyc2hpcCcsIHBhZ2VXaWR0aCAvIDIsIG1hcmdpbiwgeyBhbGlnbjogJ2NlbnRlcicgfSk7XG4gICAgXG4gICAgLy8gRGF0ZSBsaW5lXG4gICAgZG9jLnNldERyYXdDb2xvcigyNTUsIDI1NSwgMjU1KTtcbiAgICBkb2Muc2V0TGluZVdpZHRoKDAuNSk7XG4gICAgZG9jLmxpbmUobWFyZ2luLCBtYXJnaW4gKyA0LCBwYWdlV2lkdGggLSBtYXJnaW4sIG1hcmdpbiArIDQpO1xuICAgIFxuICAgIC8vIEV4cG9ydCBkYXRlXG4gICAgZG9jLnNldEZvbnRTaXplKDExKTtcbiAgICBkb2Muc2V0VGV4dENvbG9yKDI1NSwgMjU1LCAyNTUpO1xuICAgIGRvYy5zZXRGb250KCdoZWx2ZXRpY2EnLCAnbm9ybWFsJyk7XG4gICAgZG9jLnRleHQoYEV4cG9ydCBEYXRlOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1HQicpfWAsIHBhZ2VXaWR0aCAvIDIsIG1hcmdpbiArIDEwLCB7IGFsaWduOiAnY2VudGVyJyB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBhZGRCcmFuZGluZzonLCBlcnJvcik7XG4gICAgLy8gQ29udGludWUgZXhlY3V0aW9uIGV2ZW4gaWYgYnJhbmRpbmcgZmFpbHNcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYSBmb290ZXIgdG8gZWFjaCBwYWdlXG4gKi9cbmZ1bmN0aW9uIGFkZEZvb3Rlcihkb2MsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgcGFnZU51bWJlciwgdG90YWxQYWdlcywgbWFyZ2luKSB7XG4gIHRyeSB7XG4gICAgLy8gRm9vdGVyIGxpbmVcbiAgICBkb2Muc2V0RHJhd0NvbG9yKDIwMCwgMjAwLCAyMDApO1xuICAgIGRvYy5zZXRMaW5lV2lkdGgoMC41KTtcbiAgICBkb2MubGluZShtYXJnaW4sIHBhZ2VIZWlnaHQgLSAxNSwgcGFnZVdpZHRoIC0gbWFyZ2luLCBwYWdlSGVpZ2h0IC0gMTUpO1xuICAgIFxuICAgIC8vIFBhZ2UgbnVtYmVycyBhbmQgY29uZmlkZW50aWFsaXR5IG5vdGljZVxuICAgIGRvYy5zZXRGb250U2l6ZSg4KTtcbiAgICBkb2Muc2V0VGV4dENvbG9yKDEyMCwgMTIwLCAxMjApO1xuICAgIGRvYy5zZXRGb250KCdoZWx2ZXRpY2EnLCAnbm9ybWFsJyk7XG4gICAgZG9jLnRleHQoXG4gICAgICBgU2tlZ25lc3MgJiBEaXN0cmljdCBSdW5uaW5nIENsdWIgLSBDb25maWRlbnRpYWwgLSBQYWdlICR7cGFnZU51bWJlcn0gb2YgJHt0b3RhbFBhZ2VzfWAsXG4gICAgICBwYWdlV2lkdGggLyAyLFxuICAgICAgcGFnZUhlaWdodCAtIDgsXG4gICAgICB7IGFsaWduOiAnY2VudGVyJyB9XG4gICAgKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBhZGRGb290ZXI6JywgZXJyb3IpO1xuICAgIC8vIENvbnRpbnVlIGV4ZWN1dGlvbiBldmVuIGlmIGZvb3RlciBmYWlsc1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhcHByb3ByaWF0ZSBjb2x1bW4gc3R5bGVzIGJhc2VkIG9uIHRoZSBjb2x1bW5zIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGdldENvbHVtblN0eWxlcyhjb2x1bW5zKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3R5bGVzID0ge307XG4gICAgXG4gICAgLy8gU2V0IHdpZHRoIGZvciBlYWNoIGNvbHVtbiB0eXBlXG4gICAgY29sdW1ucy5mb3JFYWNoKChjb2wsIGluZGV4KSA9PiB7XG4gICAgICBzd2l0Y2goY29sLmRhdGFLZXkpIHtcbiAgICAgICAgY2FzZSAnZmlyc3RfbmFtZSc6XG4gICAgICAgIGNhc2UgJ3N1cm5hbWUnOlxuICAgICAgICAgIHN0eWxlc1tpbmRleF0gPSB7IGNlbGxXaWR0aDogMjUgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZW1haWwnOlxuICAgICAgICAgIHN0eWxlc1tpbmRleF0gPSB7IGNlbGxXaWR0aDogNTAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGF0ZV9vZl9iaXJ0aCc6XG4gICAgICAgIGNhc2UgJ21lbWJlcnNoaXBfZXhwaXJ5JzpcbiAgICAgICAgICBzdHlsZXNbaW5kZXhdID0geyBjZWxsV2lkdGg6IDI1LCBoYWxpZ246ICdjZW50ZXInIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0YXR1cyc6XG4gICAgICAgIGNhc2UgJ21lbWJlcnNoaXBfc3RhdHVzJzpcbiAgICAgICAgY2FzZSAncGF5bWVudF9zdGF0dXMnOlxuICAgICAgICAgIHN0eWxlc1tpbmRleF0gPSB7IGNlbGxXaWR0aDogMjUsIGhhbGlnbjogJ2NlbnRlcicgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZWFfbnVtYmVyJzpcbiAgICAgICAgICBzdHlsZXNbaW5kZXhdID0geyBjZWxsV2lkdGg6IDMwLCBoYWxpZ246ICdjZW50ZXInIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3R5bGVzW2luZGV4XSA9IHsgY2VsbFdpZHRoOiAnYXV0bycgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gc3R5bGVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldENvbHVtblN0eWxlczonLCBlcnJvcik7XG4gICAgcmV0dXJuIHt9OyAvLyBSZXR1cm4gZW1wdHkgb2JqZWN0IGFzIGZhbGxiYWNrXG4gIH1cbn1cblxuLyoqXG4gKiBGb3JtYXRzIGEgZGF0ZSBzdHJpbmcgdG8gREQvTU0vWVlZWVxuICovXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGVTdHJpbmcpIHtcbiAgaWYgKCFkYXRlU3RyaW5nKSByZXR1cm4gJ05vdCBzZXQnO1xuICBcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZyk7XG4gICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkgcmV0dXJuICdJbnZhbGlkIGRhdGUnO1xuICAgIFxuICAgIHJldHVybiBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tR0InKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0RhdGUgZm9ybWF0dGluZyBlcnJvcjonLCBlKTtcbiAgICByZXR1cm4gZGF0ZVN0cmluZyB8fCAnTm90IHNldCc7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3JtYXRzIHN0YXR1cyB3aXRoIHByb3BlciBjYXBpdGFsaXphdGlvblxuICovXG5mdW5jdGlvbiBmb3JtYXRTdGF0dXMoc3RhdHVzKSB7XG4gIGlmICghc3RhdHVzKSByZXR1cm4gJ1BlbmRpbmcnO1xuICBcbiAgdHJ5IHtcbiAgICByZXR1cm4gc3RhdHVzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RhdHVzLnNsaWNlKDEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcignU3RhdHVzIGZvcm1hdHRpbmcgZXJyb3I6JywgZSk7XG4gICAgcmV0dXJuIHN0YXR1cyB8fCAnUGVuZGluZyc7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJqc1BERiIsImF1dG9UYWJsZSIsImV4cG9ydE1lbWJlcnNUb1BERiIsIm1lbWJlcnMiLCJleHBvcnRUeXBlIiwiZG9jIiwib3JpZW50YXRpb24iLCJ1bml0IiwiZm9ybWF0IiwicGFnZVdpZHRoIiwiaW50ZXJuYWwiLCJwYWdlU2l6ZSIsImdldFdpZHRoIiwicGFnZUhlaWdodCIsImdldEhlaWdodCIsIm1hcmdpbiIsImN1cnJlbnREYXRlIiwiRGF0ZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsImFkZEJyYW5kaW5nIiwic2V0UHJvcGVydGllcyIsInRpdGxlIiwic3ViamVjdCIsImF1dGhvciIsImNyZWF0b3IiLCJzdGFydFkiLCJzZXRGb250Iiwic2V0Rm9udFNpemUiLCJzZXRUZXh0Q29sb3IiLCJ0ZXh0IiwiYWxpZ24iLCJzYWZlTWVtYmVycyIsIkFycmF5IiwiaXNBcnJheSIsImFwcHJvdmVkQ291bnQiLCJmaWx0ZXIiLCJtIiwic3RhdHVzIiwibGVuZ3RoIiwicGVuZGluZ0NvdW50IiwicGFpZENvdW50IiwicGF5bWVudF9zdGF0dXMiLCJjb21wZXRpdGlvbnNDb3VudCIsIm9wdF9pbl9jb21wZXRpdGlvbnMiLCJhYWdhQ291bnQiLCJvcHRfaW5fYWFnYV9jaGFsbGVuZ2UiLCJhY3RpdmVDb3VudCIsIm1lbWJlcnNoaXBfc3RhdHVzIiwic3RhdHNCb3hZIiwic3RhdHNCb3hIZWlnaHQiLCJzZXRGaWxsQ29sb3IiLCJyb3VuZGVkUmVjdCIsImNvbHVtbnMiLCJyb3dzIiwiaGVhZGVyIiwiZGF0YUtleSIsIm1hcCIsImZpcnN0X25hbWUiLCJzdXJuYW1lIiwiZW1haWwiLCJkYXRlX29mX2JpcnRoIiwiZm9ybWF0RGF0ZSIsImZvcm1hdFN0YXR1cyIsImVhX251bWJlciIsIm1lbWJlcnNoaXBfZXhwaXJ5IiwiY29tcGV0aXRpb25NZW1iZXJzIiwiYWFnYU1lbWJlcnMiLCJoZWFkIiwiY29sIiwiYm9keSIsInJvdyIsImxlZnQiLCJyaWdodCIsInN0eWxlcyIsImZvbnRTaXplIiwiY2VsbFBhZGRpbmciLCJ2YWxpZ24iLCJvdmVyZmxvdyIsInRleHRDb2xvciIsImhhbGlnbiIsIm1pbkNlbGxIZWlnaHQiLCJsaW5lV2lkdGgiLCJoZWFkU3R5bGVzIiwiZmlsbENvbG9yIiwiZm9udFN0eWxlIiwiYWx0ZXJuYXRlUm93U3R5bGVzIiwiY29sdW1uU3R5bGVzIiwiZ2V0Q29sdW1uU3R5bGVzIiwiZGlkRHJhd1BhZ2UiLCJkYXRhIiwicGFnZU51bWJlciIsImFkZEZvb3RlciIsImdldE51bWJlck9mUGFnZXMiLCJmaWxlbmFtZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJzYXZlIiwiZXJyb3IiLCJjb25zb2xlIiwibWVzc2FnZSIsInN0YWNrIiwicmVjdCIsInNldERyYXdDb2xvciIsInNldExpbmVXaWR0aCIsImxpbmUiLCJ0b3RhbFBhZ2VzIiwiZm9yRWFjaCIsImluZGV4IiwiY2VsbFdpZHRoIiwiZGF0ZVN0cmluZyIsImRhdGUiLCJpc05hTiIsImdldFRpbWUiLCJlIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/pdfExportHelper.js\n"));

/***/ })

});